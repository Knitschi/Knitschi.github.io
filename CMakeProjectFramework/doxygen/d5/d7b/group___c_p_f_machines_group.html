<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CMakeProjectFramework: CPFMachines</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="CMakeProjectFramework"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CMakeProjectFramework
   </div>
   <div id="projectbrief">A CMake and Jenkins based C++ CI pipeline.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">CPFMachines</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides a script that sets up a jenkins-server, jenkins-slaves and a web-server on machines in a local network.  
<a href="#details">More...</a></p>
<p>The CPF infrastructure includes a Jenkins server, build slaves and web-servers for hosting the generated html pages. This package provides a python script for setting up these servers. The setup script requires a user provided configuration file and ssh access to all involved machines in the network.</p>
<p>The jenkins server can be configured to contain build-jobs for CPF based repositories. For each of these projects, a web-server is set up to host the html content that is generated by the CPF-projects build pipeline.</p>
<p><a class="el" href="../../db/d51/namespace_c_p_f_machines.html">CPFMachines</a> also provides a python script to deploy post-receive hooks to the cpf-project repositories.</p>
<hr/>
<h1><a class="anchor" id="CPFMachinesUsageSection"></a>
Usage</h1>
<h2><a class="anchor" id="CPFMachinesRequirementsSubsection"></a>
Requirements</h2>
<ul>
<li>At least one Linux Machine.</li>
<li>For Windows builds, an additional Windows machine is required.</li>
<li>All machines must be in a local network, that also contains the machine that runs the setup script.</li>
<li>Linux machines must be accessible via OpenSSH from the script-runner.</li>
<li>Linux machines must have docker installed.</li>
<li>Windows machines must be accessible via "Bitvise SSH Server" from the script-runner.</li>
<li>Windows machines must have the <code>slave.jar</code> copied to "C:\jenkins"?</li>
<li>On windows build-slaves all tools that are required to run the CPF pipeline must be manually installed.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000005">Todo:</a></b></dt><dd>Setup infrastructure on fresh systems and complete the list.</dd></dl>
<h2><a class="anchor" id="CPFMachinesSetupSubsection"></a>
Setting up the infrastructure</h2>
<p>After setting up the host-machines and getting the <a class="el" href="../../db/d51/namespace_c_p_f_machines.html">CPFMachines</a> package, you are ready to set up the servers that are involved in the CPF infrastructure. If you want to use the infrastructure for multiple projects, it is recommended that you create an extra CPF-project that holds the configuration files that are needed when running the setup scripts. If you use the jenkins server for a single CPF-project you can add the configuration files to the global files if that project. In both cases you will have to add the <a class="el" href="../../db/d51/namespace_c_p_f_machines.html">CPFMachines</a> and most likely the CPFJenkinsjob package to the CPF-project that holds the configuration files.</p>
<h3><a class="anchor" id="CPFMachinesConfigurationsSubsubsection"></a>
Machine configuration</h3>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000006">Todo:</a></b></dt><dd>Automatically add the content of the example config file here and manually add comments.</dd></dl>
<h3><a class="anchor" id="CPFMachinesRunningSubsubsection"></a>
Running the script</h3>
<p>When you added the configuration file to the project, you are ready to go. Start the setup script by running</p>
<div class="fragment"><div class="line">python -m Sources.CPFMachines.setup Sources/MyCPFMachinesConfig.json</div></div><!-- fragment --><p>in the root directory of your project. This may take some time because some of the tools required for the pipeline build need to be compiled while setting up the docker container. If everything went well the script ends with the output</p>
<div class="fragment"><div class="line">Successfully startet jenkins master, build slaves and the documentation server.</div></div><!-- fragment --><p>If you used the example config file, you should now be able to access the Jenkins web-interface under <a href="http://MyMaster:8080">http://MyMaster:8080</a> and the projects web-server under <a href="http://MyMaster:80">http://MyMaster:80</a>. However, the links to your projects will only work after running their build-jobs.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000007">Todo:</a></b></dt><dd>Change webserver file structure, that multiple project pages can be served (serachindex?) and an index.html in the base directory provides links to the single projects.</dd></dl>
<h1><a class="anchor" id="CPFMachinesProblemsSection"></a>
Problems</h1>
<ul>
<li>Machine names in the config.json files should be given in lower case only, or problems with authenticating ssh server hosts can occur.</li>
<li>I was not able to make name resolution for windows machines in the host network work inside the docker containers. The machine names for the windows build-slaves therefore must be given as ip addresses to allow the jenkins-master to reach them.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>All machines should be within a trusted network as machine to machine communication is currently vulnerable to man in the middle attacks due to ignoring ssh host key checking.</dd></dl>
<h1><a class="anchor" id="CPFMachinesHookSetupSection"></a>
Automatic build-Job execution</h1>
<p>In day to day development it is practical when the build-job is run automatically whenever a developer pushes commits that should be integrated into a main branch of the project. To enable that CPFJenkinsjob provides a python module that adds hook scripts to the repositories of your CPF-projects.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000008">Todo:</a></b></dt><dd>Add documentation for hook config and how to run it.</dd></dl>
<h1><a class="anchor" id="JobParameterSection"></a>
Running the CPF Jenkins job</h1>
<p>The jenkins job that is created by this package is a parameterized job. The parameters can be used to execute multiple tasks on a CPF CI-project when the job is started via the Jenkins web-interface.</p>
<h2><a class="anchor" id="JobSubsection1"></a>
1. Integrating new commits</h2>
<p>In this mode, the job verifies the commits made to an integration branch by building the pipeline in all configurations, merge the commits to a main branch and add a new internal-version tag to mark the commit as a successful build. The project web-page will be updated with the latest version of the generated documentation. This mode is the most common use case, which should be triggered automatically when pushing commits to an integration branch of the build repository or one of the package repositories.</p>
<p>To do an integration job following parameters must be set:</p>
<ul>
<li><b>branchOrTag:</b> origin/&lt;name&gt;-int-&lt;MainBranch&gt;</li>
<li><b>task:</b> integration</li>
<li><b>package:</b> If a package was changed, this must be set to the package name. Note that this must be a package that has its versioning handled by this build project.</li>
</ul>
<p>all other can be left at their defaults.</p>
<h2><a class="anchor" id="JobSubsection2"></a>
2. Tagging a commit with a release version</h2>
<p>In this mode the job will overwrite an existing internal version tag with a release version and rebuild the tagged commit to create build artifacts with the new version. In this case you need to specify which part/digit of the version number should be incremented. The less significant digits are reset to zero. This will also update the projects web-page.</p>
<p>To create a release tag, the following parameters must be set:</p>
<ul>
<li><b>branchOrTag:</b> existing internal version-tag</li>
<li><b>task:</b> one of incrementMajor, incrementMinor, incrementPatch</li>
</ul>
<p>all other can be left at their defaults.</p>
<h2><a class="anchor" id="JobSubsection3"></a>
3. Rebuild an existing commit</h2>
<p>Sometimes it is necessary to rebuild an already integrated commit in order to recreate build artifacts. In this mode, the job will not touch the version tags are changed. This will also update the projects web-page. When none of the jobs default parameters are changed, it executes this task for the master branch.</p>
<p>To rebuild an existing commit the following parameters must be set:</p>
<ul>
<li><b>branchOrTag:</b> &lt;version-tag&gt;</li>
</ul>
<p>all other can be left at their defaults.</p>
<h2><a class="anchor" id="JobSubsection4"></a>
4. Testing or debugging the job itself</h2>
<p>When working on the CMakeProjectFramework itself, it is sometimes useful to speed up the build-job by running it with a reduced workload and without modifying the repository. Reducing the workload can be achieved by limiting the build to a special configuration and/or a special target.</p>
<p>In this case the following parameters must be set:</p>
<ul>
<li><b>branchOrTag:</b> origin/&lt;someBranch&gt; (this should be the branch you work on)</li>
<li><b>task:</b> rebuild</li>
<li><b>package:</b> The package you work on.</li>
<li><b>cpfConfiguration:</b> The configuration you are interested in.</li>
<li><b>target:</b> The target that is build.</li>
</ul>
<h1><a class="anchor" id="CPFMachinesNotesSection"></a>
Notes</h1>
<ul>
<li>With the current implementation, parallel execution of the build-job is not possible. This is because the version of a commit must stay the same while the job is running, because the current version number is retrieved multiple times from the repository while the job is running. Chaning the number in the meantime would lead to inconsistencies. In the longer run it would be good to remove this limitation, which could be a showstopper for highly frequented projects with long buildtimes. Another problem is that we do not get a build for each push, which makes it harder to pinpoint failed builds to a specific push/developer.</li>
<li>When using the CPF on Windows, one may be hitting the 260 character limit for filenames. On Windows 10, this limit can be switched off. When building on older windows versions, the user can try to reduce the length of his configuration names, package names or ci-project name.</li>
</ul>
<h1><a class="anchor" id="CPFMachinesTestsSection"></a>
Tests</h1>
<p>This is a list of non automated tests. This should only be a stopgap solution until they are automated.</p>
<h2><a class="anchor" id="CPFMachinesTestsVerioningSection"></a>
Tests for versioning mechanics</h2>
<ul>
<li>Running a successful build for an already pushed commit without a version tag should add an internl version tag to that commit.</li>
<li>Setting a release version tag should only work when the build is run on an internal version tag.</li>
<li>It should not be possible to create a release version tag that already exists.</li>
<li>When createin a release version, the old internal version tag should be deleted.</li>
<li>Owned packages should be updated during the job run if new commits are available.</li>
<li>The job should fail when release tagging a non owned package </li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 29 2018 12:18:43 for CMakeProjectFramework by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
