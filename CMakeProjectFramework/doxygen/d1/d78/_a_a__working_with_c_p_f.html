<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CMakeProjectFramework: Working with a CPF project</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="CMakeProjectFramework"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CMakeProjectFramework
   </div>
   <div id="projectbrief">A CMake and Jenkins based C++ CI pipeline.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Working with a CPF project </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page provides information on how to do the day to day tasks that arise when working with a <b>CPF</b> project. To illustrate the required steps, the text refers to an example project that can be retrieved on Github.</p>
<h1><a class="anchor" id="Prerequisites"></a>
Setting up the environment</h1>
<p>Before you start, you have to install the basic tools that are used by the CMakeProjectFramework.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000013">Todo:</a></b></dt><dd>Find out what must be installed by hand to compile the project.</dd></dl>
<p>Windows</p><ul>
<li>Visual Studio 2017</li>
<li>Git</li>
<li>Python3</li>
<li>CMake 3.10</li>
<li>OpenCppCoverage (optional)</li>
</ul>
<p>Linux</p><ul>
<li>Gcc</li>
<li>Git</li>
<li>Python3</li>
<li>CMake 3.10</li>
<li>Clang (optional)</li>
<li>Valgrind (optional)</li>
</ul>
<p>Git, Python and CMake should be callable from the command-line. (PATH on Windows)</p>
<h1><a class="anchor" id="GettingACPFProject"></a>
Cloning the example project</h1>
<p>A CPF project must be based on a git repository. The CMake code relies on it when determining package versions and when handling packages that can be contained in git submodules. Because of the possibly contained submodules the repository must be cloned by using:</p>
<div class="fragment"><div class="line">git clone --recursive https://github.com/Knitschi/ACPFTestProject.git</div></div><!-- fragment --><h1><a class="anchor" id="ConfigureGenerateBuild"></a>
Configure, generate and build a CPF project</h1>
<p>In order to build a freshly cloned CPF project, four commands need to be exectuted. Sadly this is a little more effort then the normal two steps (<em>generate</em> and <em>build</em>) that are used for a <em>vanilla</em> CMake project. The steps are implemented with the following <em>Python 3</em> scripts.</p>
<ol type="1">
<li><b>0_CopyScritps.py</b>: Add commands to the projects root directory.</li>
<li><b><a class="el" href="../../d2/d20/1___configure_8py.html">1_Configure.py</a></b>: Set variables that determine the compiler etc.</li>
<li><b><a class="el" href="../../d9/d12/2___generate_8py.html">2_Generate.py</a></b>: Create the <em>make-files</em> for the project.</li>
<li><b><a class="el" href="../../d1/dda/3___make_8py.html">3_Make.py</a></b>: Build the project.</li>
</ol>
<p>If you have your operating system configured to run <code></code>.py files with python 3, you can omit the explicit call to <code>python</code> in the following command line examples. If this is not the case, make sure the <code>python --version</code> call returns a a 3.X version. On Linux you may need to use <code>python3</code> instead of <code>python</code>.</p>
<h2><a class="anchor" id="CopyStep"></a>
The copy step</h2>
<p>In order to execute the copy step run</p>
<div class="fragment"><div class="line">...\ACPFTestProject&gt;python Sources/CPFBuildscripts/0_CopyScritps.py</div></div><!-- fragment --><p>in the project root directory.</p>
<p>This step copies some python scripts into the projects root directory. The scripts are provided by the CPFBuildscripts package. The scripts are only copied to shorten the command-line calls to these scripts while working with the project. This step only needs to be executed once after cloning the repository.</p>
<h2><a class="anchor" id="ConfigurationStep"></a>
The configuration step</h2>
<p>In order to generate a configuration file run</p>
<div class="fragment"><div class="line">.../ACPFTestProject&gt;python 1_Configure.py VS --inherits VS2017-shared</div></div><!-- fragment --><p>on Windows or</p>
<div class="fragment"><div class="line">.../ACPFTestProject&gt;python3 1_Configure.py Gcc --inherits Gcc-shared-debug</div></div><!-- fragment --><p>on Linux in the project root directory.</p>
<p>The purpose of the configuration step is to create a <code>.config.cmake</code> file that contains a set of CMake cache variables. These variables determine things like the CMake <em>generator</em>, or which custom targets are included in the pipeline. The config file is used instead of the usual variable definitions in the CMake generate step. The created file is located in the <code>Configuration</code> sub-directory. The name of the configuration (here <code>VS</code> or <code>Gcc</code>) can be chosen freely.</p>
<p>The <code>--inherits</code> option determines a base configuration from which the created file inherits default values for all required variables. The base configuration can be provided by the CPFCMake package or the projects <code>CIBuildConfigurations</code> directory, which is the common use case. Some of the values in the configuration file, like library locations or test file directories, may be need to set to values that are specific to the machine onto which the project was cloned. After running the script you have the chance to edit the default values in the created config file in order to change the values to something that is adequate for the local build. On a CI server it may sometimes be useful to set non default values of variables directly with the command line call. This can be done by adding <code>-D</code> options to the script call.</p>
<div class="fragment"><div class="line">...\ACPFTestProject&gt;1_Configure.py VS --inherits VS2017-shared --DHUNTER_ROOT=&quot;C:/MyHunterLibs&quot; --DCPF_TEST_FILES_DIR==&quot;C:/Temp&quot;</div></div><!-- fragment --><p>A project can have multiple configurations in parallel. This can be achieved by running the <code><a class="el" href="../../d2/d20/1___configure_8py.html">1_Configure.py</a></code> script, multiple times. However, short command versions for the following generate and build steps are only available when only one configuration is present.</p>
<h3><a class="anchor" id="NotesOnConfigurations"></a>
Notes on the configuration file mechanism</h3>
<p>The custom mechanism with the additional configuration file distinguishes the work-flow of the CPF project from the standard CMake command-line work-flow, where the configure and generate step are executed at the same time. A caveat of this approach is, that configuration information is duplicated in the <code>config.cmake</code> file and the <code>CMakeCache.txt</code> file. The developer has to remember that instead of editing the <code>CMakeCache.txt</code> file one now has to edit the <code>config.cmake</code> file and then re-execute the generate step. The additional command line call may also come unexpected to developers who are used to work with <em>normal</em> CMake projects.</p>
<p>However, CMake itself provides a similar three step work-flow when using the CMake-GUI application. Here the user can also change values of variables in the <code>CMakeCache.txt</code> file before executing the generate step. This indicates that there is a certain need for a three-step approach.</p>
<p>The CPF mechanism has some advantages over the two step work-flow which in my opinion outweigh the disadvantages.</p>
<ul>
<li>Developers are relieved of remembering long lists of variable definitions that need to be typed whenever they need to re-generate the project. Especially when working on cmake code it becomes often necessary to completely delete the build directory. With the CPF mechanism the possibly manually edited configuration survives the deletion of the build directory.</li>
<li>The project can define default configurations that are used by the projects CI job. This can be used to define with which compilers and on which platforms the project can be build.</li>
</ul>
<h2><a class="anchor" id="GenerateStep"></a>
The generate step</h2>
<p>To execute the generate step run</p>
<div class="fragment"><div class="line">...\ACPFTestProject&gt;python 2_Generate.py VS</div></div><!-- fragment --><p>on Windows or</p>
<div class="fragment"><div class="line">.../ACPFTestProject&gt;python3 2_Generate.py Gcc</div></div><!-- fragment --><p>on Linux in the project root directory.</p>
<p>The generate step is the equivalent to the normally used <code>cmake -H. -B_build -G"generator" -D...</code> call. It will create the build-directory <code>Generated/VS</code> that holds the created <em>make-files</em> for the generator that is set in the config file. In the example this is the Visual Studio solution for the Windows case and the make files in the Linux case.</p>
<p>Note that during this step the hunter package manager may retrieve and compile external dependencies of the project. This means that this step may take quite some time when running it for the first time. After the first run, hunter-package build results are cached and subsequent executions of this step should be much faster.</p>
<p>When called with the configuration argument, the script will delete the build directory before generating the make-files, to guarantee that its content is clean. The script can be called without the configuration argument. In this case it will use the first configuration that is available in the <em>Configuration</em> directory. It will also not delete the build directory before generating the files and do a faster <em>incremental</em> generate instead.</p>
<dl class="bug"><dt><b><a class="el" href="../../de/da5/bug.html#_bug000002">Bug:</a></b></dt><dd>The script sometimes fails to clear the build directory This can probably happen in combination with the tortoise git client, which is known to prevent files from being deleted. Repeated execution of the script will at some point lead to all files being cleared and the cmake command being executed.</dd></dl>
<h2><a class="anchor" id="BuildStep"></a>
The build step</h2>
<p>To execute a full build run</p>
<div class="fragment"><div class="line">...\ACPFTestProject&gt;python 3_Make.py VS --target pipeline --config Debug</div></div><!-- fragment --><p>on Windows or</p>
<div class="fragment"><div class="line">.../ACPFTestProject&gt;python3 3_Make.py Gcc --target pipeline</div></div><!-- fragment --><p>on Linux. This will compile the binaries as well as executing extra pipeline tasks like running the tests, do analysis, generate the documentation or other steps that your project may have enabled via its configuration file.</p>
<ul>
<li>Specifying the the cpf-configuration, will cause a fresh rebuild. If no cpf-configuration is specified, the script will do an incremental build for the first configuration in the <em>Generated</em> directory.</li>
<li>With the <code>--target</code> option one can specify which target should be build. During development this is useful if only a smaller part of the pipeline should be executed. For a list of available targets take a look at the list in the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#CustomTargetsInACPFProject">custom targets section</a>. If the <code>--target</code> option is omitted completely, the script will only build the binary targets of the project.</li>
<li>The <code>--config</code> option is only required for multi-configuration generators like Visual Studio. If it is not specified, the <code>Debug</code> configuration will be build.</li>
</ul>
<h1><a class="anchor" id="TheAnatomyOfACPFProject"></a>
The anatomy of a CPF project</h1>
<p>Now that you have built the project, it is time to take a look at the content of the test project.</p>
<h2><a class="anchor" id="DirectoryStructure"></a>
The directory structure</h2>
<p>The CMakeProjectFramework enforces a certain directory structure. Here are the most important parts of that directory layout. Note that depending on the configuration that you built not all of the shown directories and files will exist in your project. Many of the displayed directories do not exist in a freshly cloned CPF project.</p>
<div class="fragment"><div class="line">ACPFTestProject</div><div class="line">│   .gitignore</div><div class="line">│   .gitmodules</div><div class="line">│   1_Configure.py</div><div class="line">│   2_Generate.py</div><div class="line">│   3_Make.py</div><div class="line">|   ... [other scripts that help with day to day tasks]</div><div class="line">|</div><div class="line">├───Configuration</div><div class="line">│       VS.config.cmake</div><div class="line">│       Gcc.config.cmake</div><div class="line">│       ... [possibly more configuration files]</div><div class="line">│</div><div class="line">├───Generated</div><div class="line">│   ├───VS</div><div class="line">│   │   │   CMakeCache.txt</div><div class="line">│   │   │   CMakeGraphVizOptions.cmake</div><div class="line">│   │   │   CPFDependencies.dot</div><div class="line">│   │   │</div><div class="line">│   │   ├───BuildStage</div><div class="line">│   │   ├───html</div><div class="line">│   │   ├───_CPF</div><div class="line">│   │   ├───_pckg</div><div class="line">│   │   ... [the usual CMake generated directories and files]</div><div class="line">│   │</div><div class="line">│   ├───Gcc</div><div class="line">│   ... [more configuration directories]</div><div class="line">│</div><div class="line">└───Sources</div><div class="line">    │   CMakeLists.txt</div><div class="line">    │   cpfOwnedPackages.cmake</div><div class="line">    │   DoxygenConfig.txt</div><div class="line">    │   DoxygenLayout.xml</div><div class="line">    │</div><div class="line">    ├───CIBuildConfigurations</div><div class="line">    │   cpfCiBuildConfigurations.json</div><div class="line">    │   VS2017-shared.config.cmake</div><div class="line">    │   Gcc-shared-debug.config.cmake    </div><div class="line">    │   ... [more config files]</div><div class="line">    │            </div><div class="line">    ├───documentation</div><div class="line">    │       ACPFTestProjectDocumentation.dox</div><div class="line">    │       ... [more global files]</div><div class="line">    │</div><div class="line">    ├───APackage</div><div class="line">    │   │   CMakeLists.txt</div><div class="line">    │   │   function.cpp</div><div class="line">    │   │   function.h</div><div class="line">    │   │   ... [more package source files]</div><div class="line">    │   │</div><div class="line">    │   ├───MyCustomDirectory</div><div class="line">    │   |   ... [source files in sub-directories]</div><div class="line">    │   |</div><div class="line">    |   ... [more package subdirectories]</div><div class="line">    │  </div><div class="line">    ├───BPackage</div><div class="line">    │</div><div class="line">    ... [more package directories or global file directories]</div></div><!-- fragment --><h3><a class="anchor" id="RootDirectory"></a>
The root directory</h3>
<p>The <em>ACPFTestProject</em> directory is the root directory of the project. This is the directory that you get when cloning a CPF project. Most of the command line operations that are needed to handle the CPF project, are executed in this directory. The directory contains scripts to configure and build the project. It also contains the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#SourcesDirectory">Sources</a>, <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#ConfigurationDirectory">Configuration</a> and <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#GeneratedDirectory">Generated</a> directories. The <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#SourcesDirectory">Sources</a> directory is stored in the repository, while the other two are generated when setting up the project.</p>
<h3><a class="anchor" id="SourcesDirectory"></a>
The Sources directory</h3>
<p>The <em>Sources</em> directory contains all the files that are checked into the repository. After cloning a CPF repository, this should be the only existing directory in the cpf-root-directory. The Sources directory contains the root <code>CMakeLists.txt</code> file of the repository, global files and directories for the packages that contain the <em>payload</em> code of the project. There is a set of files that are in every CPF project.</p>
<ul>
<li><b><code>CMakeLists.txt:</b></code> The root <code>CMakeLists.txt</code> file creates the CI-project. This is the <em>host</em> project that contains the package projects that are created by the packages <code>CMakeLists.txt</code> files. The creation of the CI-project is done by calling the <code>cpfInit()</code> function. Packages are added by calling the <code>cpfAddPackages()</code> function. Both are provided by the <a class="el" href="../../da/dc8/group___c_p_f_c_make_group.html">CPFCMake</a> package.</li>
<li><b><code>cpfOwnedPackages.cmake</code>:</b> This file defines a CMake cache variable that holds a list of package names that are <em>owned</em> by this CI-project. <em>Owned</em> means, that the CI-job that builds this repository is responsible for verifying that all automated checks for the package pass before it is marked with a version tag. More information about package ownership can be found <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#PackageOwnership">here</a>.</li>
<li><b><code>DoxygenConfig.txt:</b></code> A configuration file for Doxygen that can be used to pass options to doxygen. Note that this is not the final file that is used by doxygen. More information about the documentation generation can be found <a class="el" href="../../d5/dc9/_a_d__c_p_f_developer_docs.html#DocumentationGeneration">here</a>.</li>
<li><b><code>DoxygenLayout.xml:</b></code> A file which can be used to customize the look of the generated documentation.</li>
<li><b><code>CIBuildConfigurations:</b></code> This directory provides the CI job with information about the project configurations that should be build by the CI job. These configurations are defined in files like <code>VS.config.cmake</code> which contain a set of CMake cache variables. More information about the config file mechanism can be found <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#ConfigurationStep">here</a>.</li>
<li><b><code>CIBuildConfigurations/cpfCiBuildConfigurations.json</code>:</b> A file that contains a list of configurations that are build by the projects CI job. This is only needed if the infrastructure provided by <a class="el" href="../../d5/d7b/group___c_p_f_machines_group.html">CPFMachines</a> is used.</li>
<li><b><code>documentation:</b></code> This is an example for user added directories for global files. You can add directories to the <em>Sources</em> directory that do not contain packages, but are rather used to order your global files, like project wide documentation, etc.</li>
<li><b><code>APackage:</b></code> A directory that contains a package. The name of the package directory can be chosen by the user. It also defines the name of the main library or executable that is created by this package. A CPF project can have multiple package directories. The package directory contains all source files that belong to the package. These can hold the production code, test code or the package documentation. The package directory must contain a <code>CMakeLists.txt</code> file that calls the <code>cpfInitPackageProject()</code> and <code>cpfAddPackage()</code> functions. The directory structure within the package directory can be chosen freely. The relative directories of source files must be prepended when adding the files to the packages <code>CMakeLists.txt</code> file.</li>
</ul>
<h3><a class="anchor" id="ConfigurationDirectory"></a>
The Configuration directory</h3>
<p>The <em>Configuration</em> directory contains CMake files that define the locally used configurations of the project. This directory is generated by calling the <code><a class="el" href="../../d2/d20/1___configure_8py.html">1_Configure.py</a></code> script in the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#ConfigurationStep">configuration step</a>. This directory is used to keep manually created project configurations out of the potentially short lived <em>Generated</em> directory.</p>
<h3><a class="anchor" id="GeneratedDirectory"></a>
The Generated directory</h3>
<p>The <em>Generated</em> directory contains all files that are generated by the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#GenerateStep">generate-</a> and <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#BuildStep">build step</a>. All contents of that directory can be deleted without loosing any manual work. However you will have to re-execute the <em>generate</em> and <em>build</em> step after deleting this directory.</p>
<p>The <em>Generated</em> directory contains one subdirectory for each configuration for which the <em>generate</em> step is executed. The configuration directories are the CMake <em>build</em> directories, that contain the usual CMake generated files as well as some special directories that are created by the CMake code of the <b>CPF</b>.</p>
<h4>CPF specific build directory content</h4>
<ul>
<li><b><code>html:</b></code> The primary output directory of the project. It contains created distribution packages in the <code>Downloads</code> subdirectory. The <code>doxygen</code> subdirectory contains the entry page of the generated project page, which leads to the documentation and other optionally generated html pages like coverage report.</li>
<li><b><code>BuildStage:</b></code> This directory contains all the binaries that are generated when building the project. When running an executable during debugging or automated testing, it is run from within this directory.</li>
<li><b><code>_CPF:</b></code> A directory that is used for all internal files that are generated by the custom targets of the CPFCMake package. If everything goes well, the contents are only of interest when developing the CPFCMake package itself.</li>
<li><b><code>_pckg:</b></code> A directory that is used to accumulate the contents of the created distribution packages. If everything goes well, the contents are only of interest when developing the CPFCMake package itself.</li>
</ul>
<h2><a class="anchor" id="CIProjectAndPackageProjects"></a>
CI project vs. package projects</h2>
<p>The CPF tries to implement a system that can not only be used for managing one repository that is worked on by a single team. It also tries to support a C++ code base that is split up in small packages that can be re-used by other projects. To achieve this, a CPF project has two CMake project levels. The CI project is created in the root <code>CMakeLists.txt</code> file. It provides the interface for the CI-job and the developers to build a set of packages. It also provides information, about which configurations are build by the CI system and possibly some higher level documentation that does not really belong to a single package.</p>
<p>In the <em>Sources</em> subdirectory we have the package directories that contain the <code>CMakeLists.txt</code> files that define the package projects. Each package creates one main binary that is supposed to be used by consumers. This can be a library or an executable. The package can also contain binaries that are used for testing and its own documentation.</p>
<h3><a class="anchor" id="PackageOwnership"></a>
Package ownership</h3>
<p>A package can be owned by a CI project or be an external package. If a package is owned by a CI project it means, that this CI project is responsible for running the automated tests of the package and defining the officially supported build configurations of that the package. When using the <a class="el" href="../../db/d51/namespace_c_p_f_machines.html">CPFMachines</a> CI-job, it will also be the entity that marks successful builds of owned packages with version tags. An owned package can either be included in the CI projects git repository, or it can be a git submodule with its own repository. If it uses a git submodule it is called a <em>loose owned package</em>. In this case it's version number can advance independently of the CI-repository. Packages that are intended to be used in other projects, should be <em>loose</em> packages with their own repository to allow other projects to include the package as a git submodule. <em>Loose</em> packages lead to more and more complex <em>git work</em>, meaning that more git operations will be necessary in the day to day work. If packages are executables or not used in other projects, it is therefore recommended to make them <em>fixed</em> packages and check them directly into the CI repository.</p>
<p>External packages are always git submodules. The CI projects build-pipeline will not run the tests for these packages and exclude them when generating the documentation. An external project should have another CI project that owns that package.</p>
<h4>Example</h4>
<p>In the ACPFTestProject we have quite number of packages. The owned packages are <em>APackage</em>, <em>CPackage</em>, <em>DPackage</em> and <em>EPackage</em>. All the other packages are external packages. These are <em>BPackage</em>, <em>CPFBuildscripts</em>, <em>CPFCMake</em>, <em><a class="el" href="../../db/d51/namespace_c_p_f_machines.html">CPFMachines</a></em>, <em>FPackage</em>, <em>GPackage</em> and <em>libSwitchWarningsOff</em>. The only <em>fixed</em> package is <em>CPackage</em>. All other packages are included as git submodules.</p>
<h1><a class="anchor" id="CustomTargetsInACPFProject"></a>
The custom targets in a CPF project</h1>
<p>The build pipeline of a CPF project is implemented with CMake <em>custom-targets</em>. In order to execute one of those tasks separately from the whole pipeline, one has to build that <em>target</em> with the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#BuildStep">3_Make.py</a> script. The advantage of the custom-target mechanism is, that the used build-system handles dependency issues, rebuilding outdated targets and parallelizing task execution.</p>
<p>The availability of custom-targets in a CPF project depends on the projects configuration and its source files. Most custom targets can be disabled via the configuration file. This may be helpful if a custom implementation of the task is preferred. Some tasks require a test executable which is only created if the package has a source file that defines the main function of a test-executable.</p>
<p>The following sections provide lists of target names that can be used with the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#BuildStep">3_Make.py</a> script. The lists do not contain some private targets of the CPF that are only created as sub-steps of the targets that are of interest to the user.</p>
<p>In some IDEs like Visual Studio or KDevelop, targets are visualized and can be directly <em>build</em> from within the IDE. This may sometimes be preferred to building the targets from the command line.</p>
<h2><a class="anchor" id="GlobalTargets"></a>
Global targets</h2>
<p>A CPF project contains some targets that operate on the global level. They either execute operations that can not be done for each package in separation or <em>bundle</em> up a certain kind of per-package targets. In this case building the bundle target will simply build all per-package targets of that kind.</p>
<p>Here is a list of targets that can exist once per CPF project.</p>
<ul>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#documentation">documentation</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#distributionPackages">distributionPackages</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#dynamicAnalysis">dynamicAnalysis</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#pipeline">pipeline</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#runAllTests">runAllTests</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#runFastTests">runFastTests</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#staticAnalysis">staticAnalysis</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#versionCompatibilityChecks">versionCompatibilityChecks</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#INSTALL">INSTALL</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#ALL_BUILD">ALL_BUILD</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#ZERO_CHECK">ZERO_CHECK</a></li>
</ul>
<h2><a class="anchor" id="PackageTargets"></a>
Package targets</h2>
<p>Here is a list of targets that can exist once per CPF package.</p>
<ul>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#package">&lt;package&gt;</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#package_tests">&lt;package&gt;_tests</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#package_fixtures">&lt;package&gt;_fixtures</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#distributionPackages_package">distributionPackages_&lt;package&gt;</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#dynamicAnalysis_package">dynamicAnalysis_&lt;package&gt;</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#install_package">install_&lt;package&gt;</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#runAllTests_package">runAllTests_&lt;package&gt;</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#runFastTests_package">runFastTests_&lt;package&gt;</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#staticAnalysis_package">staticAnalysis_&lt;package&gt;</a></li>
<li><a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#checkAbiCompatibility_binary_target">checkAbiCompatibility_&lt;binary_target&gt;</a></li>
</ul>
<h2><a class="anchor" id="TargetAnnotations"></a>
Target annotations</h2>
<h3><a class="anchor" id="documentation"></a>
documentation</h3>
<p>This target runs doxygen to generate the documentation for all owned packages. It can be disabled with the <code>CPF_ENABLE_DOXYGEN_TARGET</code> variable.</p>
<h3><a class="anchor" id="distributionPackages"></a>
distributionPackages</h3>
<p>This target bundles the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#distributionPackages_package">distributionPackages_&lt;package&gt;</a> targets.</p>
<h3><a class="anchor" id="dynamicAnalysis"></a>
dynamicAnalysis</h3>
<p>This target bundles the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#dynamicAnalysis_package">dynamicAnalysis_&lt;package&gt;</a> targets.</p>
<h3><a class="anchor" id="pipeline"></a>
pipeline</h3>
<p>The top-level bundle target that will make sure that all other targets are built.</p>
<h3><a class="anchor" id="runAllTests"></a>
runAllTests</h3>
<p>This target bundles the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#runAllTests_package">runAllTests_&lt;package&gt;</a> targets.</p>
<h3><a class="anchor" id="runFastTests"></a>
runFastTests</h3>
<p>This target bundles the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#runFastTests_package">runFastTests_&lt;package&gt;</a> targets. This target is not contained in the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#pipeline">pipeline</a> target which always builds the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#runAllTests">runAllTests</a> target.</p>
<h3><a class="anchor" id="staticAnalysis"></a>
staticAnalysis</h3>
<p>This target bundles the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#runFastTests_package">runFastTests_&lt;package&gt;</a> targets. It also checks that the dependency graph of the projects binary targets is acyclic.</p>
<h3><a class="anchor" id="versionCompatibilityChecks"></a>
versionCompatibilityChecks</h3>
<p>This target bundles the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#checkAbiCompatibility_binary_target">checkAbiCompatibility_&lt;binary_target&gt;</a> targets.</p>
<h3><a class="anchor" id="INSTALL"></a>
INSTALL</h3>
<p>This target bundles the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#install_package">install_&lt;package&gt;</a> targets.</p>
<h3><a class="anchor" id="ALL_BUILD"></a>
ALL_BUILD</h3>
<p>This target builds all binary targets.</p>
<h3><a class="anchor" id="ZERO_CHECK"></a>
ZERO_CHECK</h3>
<p>This target re-runs the CMake generate step.</p>
<h3><a class="anchor" id="package"></a>
&lt;package&gt;</h3>
<p>The main binary target of the package.</p>
<h3><a class="anchor" id="package_tests"></a>
&lt;package&gt;_tests</h3>
<p>The test executable that belongs to the package. This target is only created if the <code>addPackage()</code> function has the <code>TEST_FILES</code> argument set. The executable should run automated tests when executed.</p>
<h3><a class="anchor" id="package_fixtures"></a>
&lt;package&gt;_fixtures</h3>
<p>An additional library that can be used to share test utility code between packages. It is only created if the <code>addPackage()</code> function has the <code>FIXTURE_FILES</code> and <code>PUBLIC_FIXTURE_HEADER</code> arguments set.</p>
<h3><a class="anchor" id="distributionPackages_package"></a>
distributionPackages_&lt;package&gt;</h3>
<p>Creates all <em>distribution packages</em> of the package. A <em>distribution package</em> is a file that is distributed to users of the package. This can be a zip file that contains the binaries or sources or an installer. The target is only created if the <code>addPackage()</code> function has the <code>DISTRIBUTION_PACKAGES</code> argument set.</p>
<h3><a class="anchor" id="dynamicAnalysis_package"></a>
dynamicAnalysis_&lt;package&gt;</h3>
<p>This target runs the test executable with OpenCppCoverage tool on Windows. This adds a test coverage report to the html output. On Linux it runs the test executable with the Valgrind tool. This can detect memory leaks and undefined behavior.</p>
<p>The target can be disabled with the <code>CPF_ENABLE_DYNAMIC_ANALYSIS_TARGET</code> config variable.</p>
<h3><a class="anchor" id="install_package"></a>
install_&lt;package&gt;</h3>
<p>This target copies the packages binary files and public headers to the <code>${CMAKE_INSTALL_PREFIX}/&lt;package&gt;</code> directory.</p>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000014">Todo:</a></b></dt><dd>Check if this can still be used like the Linux <code>{make</code> install} step without breaking the creation of the distribution packages.</dd></dl>
<h3><a class="anchor" id="runAllTests_package"></a>
runAllTests_&lt;package&gt;</h3>
<p>This target runs all the tests in the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#package_tests">&lt;package&gt;_tests</a> executable.</p>
<p>The target can be disabled with the <code>CPF_ENABLE_RUN_TESTS_TARGET</code> config variable.</p>
<h3><a class="anchor" id="runFastTests_package"></a>
runFastTests_&lt;package&gt;</h3>
<p>This target runs all the tests in the <a class="el" href="../../d1/d78/_a_a__working_with_c_p_f.html#package_tests">&lt;package&gt;_tests</a> executable that have either the word <em>FastFixture</em> or <em>FastTests</em> included in their name. It is the the users responsibility to make sure that the tests with those names are really fast tests.</p>
<p>The purpose of the target is to provide a way of executing only tests that are run quickly an which are therefor useful when working in a tight test-driven development cycle.</p>
<p>The target can be disabled with the <code>CPF_ENABLE_RUN_TESTS_TARGET</code> config variable.</p>
<h3><a class="anchor" id="staticAnalysis_package"></a>
staticAnalysis_&lt;package&gt;</h3>
<p>This target only exists when compiling on Linux with the clang compiler. It runs the <code>clang-tidy</code> tool on the packages source files.</p>
<p>The target can be disabled with the <code>CPF_ENABLE_STATIC_ANALYSIS_TARGET</code> config variable.</p>
<h3><a class="anchor" id="checkAbiCompatibility_binary_target"></a>
checkAbiCompatibility_&lt;binary_target&gt;</h3>
<p>The target only exists when compiling on Linux with Gcc and with debug output. It runs the Abi-Compliance-Checker tool on abi-dump files that are contained in the packages distribution targets. The tool will add ABI/API compatibility reports to the html output directory.</p>
<p>This target is somewhat fragile, because it requires the abi-dump files of the last internal and release version of the package. These must be provided by the web-server that is setup by the <a class="el" href="../../db/d51/namespace_c_p_f_machines.html">CPFMachines</a> infrastructure.</p>
<p>The target can be disabled with the <code>CPF_ENABLE_ABI_API_COMPATIBILITY_CHECK_TARGETS</code> config variable.</p>
<h1><a class="anchor" id="CommonGitOperations"></a>
Common Git operations on a CPF project</h1>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000015">Todo:</a></b></dt><dd>Describe updates and pushes.</dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 29 2018 10:27:06 for CMakeProjectFramework by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
