<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CMakeProjectFramework: Working with a CPF project</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="CMakeProjectFramework"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CMakeProjectFramework
   </div>
   <div id="projectbrief">It really whips the coders ass!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,true,'search.html','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Working with a CPF project </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page provides information on how to do the day to day tasks that arise when working with a <b>CPF</b> project.</p>
<h1><a class="anchor" id="GettingACPFProject"></a>
Getting a CPF project</h1>
<p>A <b>CPF</b> poject must be based on git. The cmake code relies on it when determening package versions and when handling packages that may come from other repositories. In general a <b>CPF</b> project can contain git submodules so you should clone it by using:</p>
<div class="fragment"><div class="line">git clone --recursive &lt;myRepo&gt;</div></div><!-- fragment --><h1><a class="anchor" id="TheAnatomyOfACPFProject"></a>
The anatomy of a CPF project</h1>
<h2><a class="anchor" id="The"></a>
directory structure</h2>
<p>The <b>CPF</b> enforces a certain directory structure. Here are the most important parts of that directory layout. Note that not all of the shown directories and files exist directly after cloning a CPF repository.</p>
<div class="fragment"><div class="line">MyCPFFProject</div><div class="line">│   .gitignore</div><div class="line">│   .gitmodules</div><div class="line">│   1<a class="code" href="../../d7/d9f/namespace___configure.html">_Configure</a>.py</div><div class="line">│   2<a class="code" href="../../d7/de5/namespace___generate.html">_Generate</a>.py</div><div class="line">│   3<a class="code" href="../../d1/d2e/namespace___make.html">_Make</a>.py</div><div class="line">|</div><div class="line">├───Configuration</div><div class="line">│       MyConfig1.config.cmake</div><div class="line">│       MyConfig2.config.cmake</div><div class="line">│       ... [more configuration files]</div><div class="line">│</div><div class="line">├───Generated</div><div class="line">│   ├───MyConfig1</div><div class="line">│   │   │   CMakeCache.txt</div><div class="line">│   │   │   CMakeGraphVizOptions.cmake</div><div class="line">│   │   │   CPFDependencies.dot</div><div class="line">│   │   │</div><div class="line">│   │   ├───BuildStage</div><div class="line">│   │   ├───html</div><div class="line">│   │   ├───_CPF</div><div class="line">│   │   ├───_pckg</div><div class="line">│   │   ... [the usual CMake generated directories and files]</div><div class="line">│   │</div><div class="line">│   ├───MyConfig2</div><div class="line">│   ... [more configuration directories]</div><div class="line">│</div><div class="line">└───Sources</div><div class="line">    │   CMakeLists.txt</div><div class="line">    │   cpfOwnedPackages.cmake</div><div class="line">    │   DoxygenConfig.txt</div><div class="line">    │   DoxygenLayout.xml</div><div class="line">    │   ... [more global files]</div><div class="line">    │</div><div class="line">    ├───CIBuildConfigurations</div><div class="line">    │   cpfCiBuildConfigurations.json</div><div class="line">    │   MyCIConfiguration.config.cmake</div><div class="line">    │            </div><div class="line">    ├───GlobalFiles</div><div class="line">    │       MyDocumentation.dox</div><div class="line">    │       ... [more global files]</div><div class="line">    │</div><div class="line">    ├───Package1</div><div class="line">    │   │   CMakeLists.txt</div><div class="line">    │   │   source.cpp</div><div class="line">    │   │   source.h</div><div class="line">    │   │   ... [more <span class="keyword">package </span>source files]</div><div class="line">    │   │</div><div class="line">    │   ├───MyCustomDirectory</div><div class="line">    │   |   ... [source files in sub-directories]</div><div class="line">    │   |</div><div class="line">    |   ... [more package subdirectories]</div><div class="line">    │  </div><div class="line">    ├───Package2</div><div class="line">    │</div><div class="line">    ... [more package directories or global file directories]</div></div><!-- fragment --><h3><a class="anchor" id="RootDirectory"></a>
The root directory</h3>
<p>The <b>MyCPFProject</b> directory is often called the cpf-root-directory. This is the directory that you get when cloning a CPF project. Most of the command line operations that are needed to handle the CPF project, are executed in this directory. The directory may contain scripts to configure and build the project. The root directory contains the <b>Sources</b>, <b>Configuration</b> and <b>Generated</b> directories. The <b>Sources</b> directory is stored in the repository, while the other two are generated when setting up the project.</p>
<h3><a class="anchor" id="SourcesDirectory"></a>
The Sources directroy</h3>
<p>The <b>Sources</b> directory contains all the files that are checked into the repository. After cloning a CPF repository, this should be the only existing directory in the cpf-root-directory. The Sources directory contains the root CMakeLists.txt file of the CI-project, CI-project files and directories for the packages that contain the <em>payload</em> code of the project. There are some files that need to be in every CPF project.</p>
<ul>
<li><b><code>CMakeLists.txt:</code> The</b> root <code>CMakeLists.txt</code> file creates the CI-project. This is the <em>host</em> project that contains the package projects that are created by the packages <code>CMakeLists.txt</code> files. The creation of the CI-project is done by calling the <code>cpfInit()</code> function. Packages are added by calling the <code>cpfAddPackages()</code> function. Both are provided by the CPFCMake package.</li>
<li><b><code><a class="el" href="../../db/df3/cpf_owned_packages_8cmake.html">cpfOwnedPackages.cmake</a>:</code> This</b> file defines a CMake cache variable that holds a list of package names that <em>owned</em> by this CI-project. <em>Owned</em> means, that the CI-job that builds this repository is responsible for verifying that all automated checks for the package pass before it is marked with a version tag.</li>
<li><b><code>DoxygenConfig.txt:</code> A</b> configuration file for Doxygen that can be used to pass options to doxygen. Note that this is not the final file that is used by doxygen. See <a class="el" href="../../de/dab/_c_p_f_developer_docs.html#DocumentationGeneration">Documentation generation</a>.</li>
<li><b><code>DoxygenLayout.xml:</code> A</b> file which can be used to customize the look of the generated documentation.</li>
<li><b><code>CIBuildConfigurations/</code>:</b> This directory provides the CI job with information about which project configurations should be build by the CI job. These configurations are defined in files like the <code>MyCIConfiguration.config.cmake</code> which contain a set of CMake cache variables. See <a class="el" href="../../db/da3/_working_with_c_p_f.html#ConfigurationStep">The configuration step</a>.</li>
<li><b><code>CIBuildConfigurations/cpfCiBuildConfigurations.json</code>:</b> A file that contains a list of configurations that are build by the projects CI job. This is only needed if the infrastructure provided by <a class="el" href="../../db/d51/namespace_c_p_f_machines.html">CPFMachines</a> is used.</li>
<li><b><code>GlobalFiles/</code>:</b> This is an example for user added directories for global files. You can add directories to the <b>Sources</b> directory that do not contain packages, but are rather used to order your global files, like project wide documentation, etc.</li>
<li><b><code>Package1/</code>:</b> A directory that contains a package. The name can be chosen by the user. The name of the directory defines the name of the main binary that is created by this package. The package directories contain the source files of the packages production and test code as well as the packages documentation. The package directory must contain a <code>CMakeLists.txt</code> file that contains the <code>cpfInitPackageProject()</code> and <code>cpfAddPackage()</code> calls. The directory structure within the package directory can be freely chosen by the user. You only have to add the relative directory when adding the file to the packages <code>CMakeLists.txt</code> file.</li>
</ul>
<h3><a class="anchor" id="ConfigurationDirectory"></a>
The Configuration directory</h3>
<p>The <b>Configuration</b> directory contains CMake files that define the locally used configurations of the project. This directory is generated by calling the <code><a class="el" href="../../d2/d20/1___configure_8py.html">1_Configure.py</a></code> script. This directory is used to keep manually created project configurations out of the potentially short lived <b>Generated</b> directory. See <a class="el" href="../../db/da3/_working_with_c_p_f.html#ConfigurationStep">The configuration step</a>.</p>
<h3><a class="anchor" id="GeneratedDirectory"></a>
The Generated directory</h3>
<p>The <b>Generated</b> directory contains all files that are generated by the CMake <em>generate</em> step and when building the projects pipeline. This includes make files or Visual Studio solution files. All contents of that directory can be deleted without loosing any manual work. However you will have to re-execute the <em>generate</em> and <em>build</em> step after deleting this directory. See <a class="el" href="../../db/da3/_working_with_c_p_f.html#GenerateStep">The generate step</a>.</p>
<p>The <b>Generated</b> directory contains a subdirectory for each configuration for which the <em>generate</em> step has been executed. The configuration directories are the <code>CMAKE_BUILD_DIR</code> directories, that contain a the usual CMake generated files as well as some special directories that are created by the cmake code of the <b>CPF</b>.</p>
<ul>
<li><b><code>html/</code>:</b> The primary output directory of the project. It contains created distribution packages in the <code>Downloads</code> subdirectory. The <code>doxygen</code> subdirectory contains the entry page of the generated project page, which leads to the documentation and other optionally generated html pages like coverage report.</li>
<li><b><code>BuildStage/</code>:</b> This directory contains all the binaries that are generated when building the project. When running an executable during debugging or automated testing, it is run from within this directory.</li>
<li><b><code>_CPF/</code>:</b> A directory that is used for all internal files that are generated by the custom targets of the CPFCMake package. If everything goes well, the contents are only of interest when developing the CPFCMake package itself.</li>
<li><b><code>_pckg/</code>:</b> A directory that is used to accumulate the contents of the created distribution packages. If everything goes well, the contents are only of interest when developing the CPFCMake package itself.</li>
</ul>
<h2><a class="anchor" id="CIProjectAndPackageProjects"></a>
CI project and package projects</h2>
<p>The CPF tries to implement a system that can not only be used for managing one repository that is worked on by a single team. It rather tries to support a C++ code base that is split up in small packages that can be reused by other projects. To achieve this, a CPF project has two CMake project levels. The CI project is created in the root <code>CMakeLists.txt</code> file. It provides the interface for the CI-job and the developers to build a set of packages. It also provides informations, about which configurations are build by the CI system and possibly some higher level documentation that does not really belong to a single package.</p>
<p>In the <code>Sources</code> subdirectory we have the package directories that contain the <code>CMakeLists.txt</code> files that define the package projects. Each package creates one main binary that is suposed to be used by consumers. This can be a library or an executable. The package can also contain binaries that are used for testing and its own documentation.</p>
<h3><a class="anchor" id="PackageOwnership"></a>
Package ownership</h3>
<p>The packages can be owned by a CI project or be external packages. If a package is owned by a CI project it means, that this CI project is responsible for running the automated tests of the package and defining the officialy suported build configurations of that the package. An owned package can either be a part of the CI projects git repository, or it can be a git submodule. If it uses a git submodule it is called a <em>loose owned package</em>.</p>
<p>External packages are always git submodules. The CI projects build-pipeline will not run the tests for these packages and exclude them when generating the documentation. An external project should have another CI project that owns that package.</p>
<h1><a class="anchor" id="ConfigureGenerateBuild"></a>
How to configure, generate and build a CPF project</h1>
<p>In order to build a freshly cloned CPF project, four commands need to be exectuted. Sadly this is a little more effort then the normal <em>generate</em> and <em>build</em> step that need to be done for a <em>vanilla</em> CMake project. All the steps are implemented with <b>python 3</b> scripts. The four steps are implemented with the for scripts</p>
<ol type="1">
<li><b>0_CopyScritps.py</b>: Add commands to the projects root directory.</li>
<li><b><a class="el" href="../../d2/d20/1___configure_8py.html">1_Configure.py</a></b>: Set variables that determine the compiler etc.</li>
<li><b><a class="el" href="../../d9/d12/2___generate_8py.html">2_Generate.py</a></b>: Create the <em>make-files</em> for the project.</li>
<li><b><a class="el" href="../../d1/dda/3___make_8py.html">3_Make.py</a></b>: Build the project.</li>
</ol>
<h2><a class="anchor" id="CopyStep"></a>
The copy step</h2>
<p>First we need to copy some python scripts into the projects root directory. The scripts are provided by the CPFBuildscripts package. The scripts are only copied to shoreten the command line calls to these scripts while working with the project. This step only needs to be executed once after cloning the repository.</p>
<p>In order to execute the copy step run</p>
<div class="fragment"><div class="line">..\MyCPFFProject&gt;python Sources/CPFBuildscripts/0_CopyScritps.py</div></div><!-- fragment --><p>in the projects root directory.</p>
<h2><a class="anchor" id="ConfigurationStep"></a>
The configuration step</h2>
<p>The purpose of the configuration step is to create a <code></code>.config.cmake file that contains a set of CMake cache variables. These variables determine things like the CMake <em>generator</em> or which custom targets are included in the pipeline. These config file is used instead of the usual variable definitions in the CMake generate step. The created file is located in the <code>Configuration</code> sub-directory.</p>
<p>In order to generate a configuration file run</p>
<div class="fragment"><div class="line">...\MyCPFFProject&gt;python 1_Configure.py MyConfiguration --inherits Linux</div></div><!-- fragment --><p>in the projects root directory.</p>
<p>The <code>&ndash;inherits</code> option determines a base configuration that is for the created file. The base configuration can be provided by the CPFCMake package or the projects <code>CIBuildConfigurations</code> directory, which is the common use case. Some of the values in the configuration file, like library locations or test file directories, may be specific to the machine onto which the project was cloned. So after the running the script you have the chance to change the default values in the created config file to something that is adequate for the local build. On a CI server it may somtimes be usefull to set non default values of variables directly with the command line call. This can be done by adding <code>-D</code> options to the script call.</p>
<div class="fragment"><div class="line">...\MyCPFFProject&gt;1_Configure.py VS2017 --inherits Windows --DHUNTER_ROOT=&quot;C:/MyHunterLibs&quot; --DCPF_TEST_FILES_DIR==&quot;C:/Temp&quot;</div></div><!-- fragment --><p>By repeatedly running the <code><a class="el" href="../../d2/d20/1___configure_8py.html">1_Configure.py</a></code> multiple configurations can be created which can exists in parallel.</p>
<h3><a class="anchor" id="NotesOnConfigurations"></a>
Notes on the configuration file mechanism</h3>
<p>The custom mechanism with the extra configuration file distinguishes the work-flow of the CPF from the standard cmake command-line work-flow, where the configure and generate step are executed at the same time. A caveat of this approach is, that configuration information is duplicated in the <code>config.cmake</code> file of the CPF and the <code>CMakeCache.txt</code> file which is generated by CMake. It also introduces an additional command line call that may come unexpected to developer who are used to the vanilla CMake work-flow.</p>
<p>However, CMake itself provides a similar three step work-flow when using the CMake-GUI application. Here the user can also change values of variables before executing the generate step. This indicates that there is certain need for a three-step approach.</p>
<p>The CPF mechanism has some advantages over the two step work-flow which in my opinion outweigh the disadvantages.</p>
<ul>
<li>Developers are relieved of remembering long lists of variable definitions that need to be typed whenever they need to re-generate the project. Especially when working on cmake code it becomes often necessary to completely delete the build directory. With the CPF mechanism the possibly manually edited configuration survives the deletion of the build directory.</li>
<li>The project can define default configurations that are used by the projects CI job. This can be used to define with which compilers and on which platforms the project can be build.</li>
</ul>
<h2><a class="anchor" id="GenerateStep"></a>
The generate step</h2>
<p>The generate step is the equivalent to the normally used <code>{cmake</code> -H. -B_build -G"generator" -D...} call. It will create the build-directory <code>Generated/MyConfiguration</code> that will then hold the make-files* for the generator set in the MyConfiguration.cmake config file.</p>
<p>To execute the generate step run</p>
<div class="fragment"><div class="line">...\MyCPFFProject&gt;python 2_Generate.py MyConfiguration</div></div><!-- fragment --><p>in the projects root directory.</p>
<p>Note that during this step the hunter package manager may retrieve and compile external dependencies of the project. This means that this step may take a while when running it for the first time. After the first run, hunter-package build results are cached and subsequent executions of this step should be much faster.</p>
<p>When called with the configuration argument, the script will delete the build directory to guarantee that its content is clean. The script can be called without the <code>MyConfiguration</code> argument. In this case it will use the first configuration that is available in the <code>Configurtaion</code> directory. It will also not delete the build directory before generating the files and do a faster <em>incremental</em> generate instead.</p>
<dl class="bug"><dt><b><a class="el" href="../../de/da5/bug.html#_bug000002">Bug:</a></b></dt><dd>The script sometimes fails to clear the build directory This can probably happen in combination with the tortoise git client, which is known to prevent files from beeing deleted. Repeated execution of the script will at some point lead to all files beeing cleared and the cmake command being executed.</dd></dl>
<h2><a class="anchor" id="BuildStep"></a>
The build step</h2>
<p>Executing this step will finally build the project. To execute the full build step run</p>
<div class="fragment"><div class="line">...\MyCPFFProject&gt;python 3_Make.py --target pipeline</div></div><!-- fragment --><p>This will compile the binaries as well as running the tests, do analysis, generate the documentation and other steps that your project may have enabled via its configuration file.</p>
<p>Whith the <code>&ndash;target</code> option one can specify any other target provided by the CPF. For a list of available targets see <a class="el" href="../../db/da3/_working_with_c_p_f.html#CustomTargetsInACPFProject">The custom targets in a CPF project</a>. If the <code>&ndash;target</code> option is ommited completely, the script will only build the binary targets of the project. The script can take a configuration name as its first argument. If that is given, it will do a fresh build for that configuration. If none is given, it will incrementally build the first configuration in the Generated directory.</p>
<p>When compiling a configuration that uses a multi-configuration generator like Visual Studio, one can also add a <code>&ndash;config</code> option to determine the build configuration.</p>
<div class="fragment"><div class="line">3_Make.py VS2017 --target pipeline --config Release</div></div><!-- fragment --><p>When no <code>&ndash;config</code> option is given when compiling a multi-configuration setup, the <code>Debug</code> configuration is build.</p>
<h1><a class="anchor" id="CustomTargetsInACPFProject"></a>
The custom targets in a CPF project</h1>
<p>The build pipeline of a CPF project is implemented with CMake 'custom-targets'. In order to execute one of those tasks separately from the whole pipeline, one has to build that 'target' with the <code><a class="el" href="../../d1/dda/3___make_8py.html">3_Make.py</a></code> script.</p>
<p>The advantage of the custom-target mechanism is, that the used build-system can determine if a task needs to be re-run or if tasks can be run in parallel.</p>
<p>Which targets exist in a CPF project depends on its configuration and its source files. Most custom targets can be disabled via the configuration file if a custom mechnism for the task is used. Some tasks require a test executable which is only created if the package has a source file that defines the main function of a test-executable.</p>
<h2><a class="anchor" id="GlobalTargets"></a>
Global targets</h2>
<p>Here is a list of targets that can exist once per CPF project.</p>
<ul>
<li>pipeline</li>
<li>documentation</li>
</ul>
<h2><a class="anchor" id="PAckageTargets"></a>
Plobal targets</h2>
<p>Here is a list of targets that can exist once per CPF package.</p>
<ul>
<li>runTests_&lt;package&gt; </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 13 2018 13:14:51 for CMakeProjectFramework by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
