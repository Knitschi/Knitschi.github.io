<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CMakeProjectFramework: Setting up a CPF project</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="../../search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="CMakeProjectFramework"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../DoxygenStylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CMakeProjectFramework
   </div>
   <div id="projectbrief">A CMake and Jenkins based C++ CI pipeline.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="../../search.html" method="get">
              <img id="MSearchSelect" src="../../search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d9/dc9/_c_p_f_setting_up_a_c_p_f_project.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Setting up a CPF project </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section shows how to create a CPF based project. Before doing so, it is recommended that you get acquainted with the <em>CMakeProjectFramework</em> by building the example project as described on the <a class="el" href="../../d4/d37/_c_p_f_working_with_c_p_f.html">Working with a CPF project</a> page. You should also have basic knowledge on how to work with Git.</p>
<h1><a class="anchor" id="StepByStep"></a>
Step by step tutorial for creating a CPF project</h1>
<p>This tutorial will walk you through the steps that are required to set-up a CPF project. It starts with a very simple project that will then be extended to show more advanced features. The goal of the tutorial is not only to create a new CPF project, but also to explain some of it's details in the process. If you already know your way around a CPF project and you just want to create a new one, it is probably quicker if you simply copy the example project and remove the stuff that you do not need and rename the rest.</p>
<p>This tutorial assumes that you work on Windows with Visual Studio 2017. It also assumes that you can run the python scripts from the command line without prepending the extra <code>python</code> command. If you want to run this tutorial on Linux, you have to use the base <em>Linux</em> configuration in the configuration step instead of the <em>Windows</em> configuration. You may also want to choose different names for your generated configurations like <em>VS</em> &rarr; <em>Gcc</em> and <em>VS2017-shared</em> &rarr; <em>Gcc-shared</em>.</p>
<p>Until not stated differently, all commands should be executed in the projects root directory. When running things on Linux there are a few differences.</p>
<p>Executables are generated in a slightly different directory with an additional <code>bin</code> subdirectory. When running executables you have to prepend <code></code>./ to the executable file. At some places you may have to replace <code>\</code> with <code>/</code>. You will have to replace commands for filesystem operations with their Linux equivalents.</p>
<h2><a class="anchor" id="CreateRepositories"></a>
1. Create the repository</h2>
<p>First you need a Git repository that will hold your CI project. For simplicity's sake we create the <em>remote</em> git repository on the same machine that we use for working on the cloned repository. If you are familiar with setting up remote Git repositories you can also create it on a different machine.</p>
<p>Navigate to a directory that is suited for holding the repositories. If you are on Windows, make sure that it is a short path. Because of the deep nested directory structure, your CPF project may get into trouble with the 260 character path limit. Create the directory <code>MyCPFPRoject.git</code>. This will contain the <em>remote</em> repository. Now open a command line, and create the remote repository by executing the following commands:</p>
<div class="fragment"><div class="line">&gt;cd MyCPFPRoject.git</div><div class="line">&gt;git init --share --bare</div></div><!-- fragment --><p>Clone the <em>remote</em> repository by executing the following commands:</p>
<div class="fragment"><div class="line">&gt;cd ..</div><div class="line">&gt;git clone MyCPFPRoject.git</div></div><!-- fragment --><p>This will create the <code>MyCPFProject</code> directory. This is the root directory of your project that we will use to add and edit source files. In the next section we will add some basic files to that repository.</p>
<h2><a class="anchor" id="BasicCIprojectFiles"></a>
2. Basic CI project files</h2>
<p>We now have the repository that will hold the files of our project. First we add the basic files that are required for a CPF project. You now have to create the files</p>
<div class="fragment"><div class="line">MyCPFProject</div><div class="line">│   .gitignore</div><div class="line">│</div><div class="line">└───Sources</div><div class="line">        CMakeLists.txt</div></div><!-- fragment --><p>with the following content:</p>
<h4>.gitignore</h4>
<p>The file will make sure that directories and files that are generated by the CPF are ignored by git.</p>
<div class="fragment"><div class="line"># file MyCPFProject/.gitignore</div><div class="line"></div><div class="line">Generated/**</div><div class="line">Generated</div><div class="line">Configuration/**</div><div class="line">Configuration</div><div class="line">Sources/*/cpfPackageVersion_*.cmake</div><div class="line">1_Configure.py</div><div class="line">2_Generate.py</div><div class="line">3_Make.py</div></div><!-- fragment --><h4>CMakeLists.txt</h4>
<p>This is the root <code>CMakeLists.txt</code> file of your CPF project.</p>
<div class="fragment"><div class="line"># file MyCPFProject/Sources/CMakeLists.txt</div><div class="line"></div><div class="line">include(&quot;CPFCMake/Variables/cpfConstants.cmake&quot;)</div><div class="line">cmake_minimum_required (VERSION ${CPF_MINIMUM_CMAKE_VERSION}) </div><div class="line"></div><div class="line">include(&quot;CPFCMake/cpfInit.cmake&quot;)</div><div class="line"></div><div class="line">project(MyCPFProject)</div><div class="line">cpfInit()</div><div class="line"></div><div class="line">set( externalPackages</div><div class="line">    cotire</div><div class="line">    CPFCMake</div><div class="line">    CPFBuildscripts</div><div class="line">)</div><div class="line"></div><div class="line">set( globalFiles</div><div class="line">)</div><div class="line"></div><div class="line">cpfAddPackages( &quot;${externalPackages}&quot; &quot;${globalFiles}&quot;)</div></div><!-- fragment --><ul>
<li><code>include("CPFCMake/Variables/cpfConstants.cmake")</code>: Including this file provides us with the <code>CPF_MINIMUM_CMAKE_VERSION</code> that is used in the next line. Alternatively you can set your own minimum version that must be equal or higher then the version that is required by the CPF.</li>
<li><code>include("CPFCMake/cpfInit.cmake")</code>: This file provides the <code>cpfInit()</code> and <code>cpfAddPackages()</code> functions.</li>
<li><code>project(MyCPFProject)</code>: This creates the so called <em>CI project</em>.</li>
<li><code>cpfInit()</code>: This function from <a class="el" href="../../da/daa/_c_p_f_c_make.html#CPFCMake">CPFCMake</a> defines custom target properties, set some CMake policies and search for some of the tools that are required by the CPF pipeline.</li>
<li><code>cpfAddPackages()</code>: This function adds the packages and global files to the CI project. We add the basic packages <em>cotire</em>, <em>CPFCMake</em> and <em>CPFBuildscripts</em> that are required for each CPF project. As the packages are not yet in our repository, we add them as git submodules in the next step.</li>
</ul>
<p>After creating the files you should now commit them to the repository and add a first version tag. The tag is required by the CPF to determine the version number of the packages. If it is missing, the CPF will later cause errors.</p>
<div class="fragment"><div class="line">&gt;git add .gitignore Sources/CMakeLists.txt</div><div class="line">&gt;git commit . -m&quot;Add basic files&quot;</div><div class="line">&gt;git tag -a 0.0.0 -m&quot;The initial version&quot;</div></div><!-- fragment --><h2><a class="anchor" id="AddCPFPackages"></a>
3. Add the CPF packages</h2>
<p>In the last section you added a <code>CMakeLists.txt</code> file that uses some functions from the <em>CPFCMake</em> package. However, you do not have those functions yet available in your project. To change that we now add three packages as git submodules. Open a command line and navigate to the <em>Sources</em> directory. Then run:</p>
<div class="fragment"><div class="line">Sources&gt;git submodule add https://github.com/Knitschi/CPFCMake.git</div><div class="line">Sources&gt;git submodule add https://github.com/Knitschi/CPFBuildscripts.git</div><div class="line">Sources&gt;git submodule add https://github.com/Knitschi/cotire.git</div></div><!-- fragment --><p>The submodules <a class="el" href="../../da/daa/_c_p_f_c_make.html#CPFCMake">CPFCMake</a> and <a class="el" href="../../df/de6/_c_p_f_buildscripts.html#CPFBuildscripts">CPFBuildscripts</a> are part of the CMakeProjectFramework. <em>Cotire</em> is an internal third party dependency of the CPF that implements the automatic use of pre-compiled headers. <br />
</p>
<h2><a class="anchor" id="CPFRunGenerateForMyCPFProject"></a>
4. Run the generate step to create some more files</h2>
<p>Now that we have acquired the CPF packages we can generate some more project files by running the generate step. Run the following commands in the project root directory.</p>
<div class="fragment"><div class="line">&gt;Sources\CPFBuildscripts\0_CopyScripts.py</div><div class="line">&gt;1_Configure.py VS --inherits Windows</div><div class="line">&gt;2_Generate.py</div></div><!-- fragment --><p>This will create three more files in the <em>Sources</em> directory. Your project tree should now look like this:</p>
<div class="fragment"><div class="line">MyCPFProject</div><div class="line">│   .gitignore</div><div class="line">│   1_Configure.py</div><div class="line">│   2_Generate.py</div><div class="line">│   3_Make.py</div><div class="line">│</div><div class="line">├───Configuration</div><div class="line">│       VS.config.cmake</div><div class="line">│</div><div class="line">├───Generated</div><div class="line">│   └───VS</div><div class="line">│           ...</div><div class="line">│</div><div class="line">└───Sources</div><div class="line">    │   CMakeLists.txt</div><div class="line">    │   cpfOwnedPackages.cmake</div><div class="line">    │</div><div class="line">    ├───cotire</div><div class="line">    │       ...</div><div class="line">    │</div><div class="line">    ├───CPFBuildscripts</div><div class="line">    │       ...</div><div class="line">    │</div><div class="line">    ├───CPFCMake</div><div class="line">    |       ...</div><div class="line">    │</div><div class="line">    └───documentation</div><div class="line">            DoxygenConfig.txt</div><div class="line">            DoxygenLayout.xml</div><div class="line">            DoxygenStylesheet.css</div></div><!-- fragment --><p>The files <code>cpfOwnedPackages.cmake</code>, <code>documentation/DoxygenConfig.txt</code>, <code>documentation/DoxygenLayout.xml</code> and <code>documentation/DoxygenStylesheet.xml</code> need to be committed to the repository because they are generated when the generate step is run for the first time. Run</p>
<div class="fragment"><div class="line">&gt;git add Sources/documentation/DoxygenConfig.txt Sources/documentation/DoxygenLayout.xml Sources/documentation/DoxygenStylesheet.xml Sources/cpfOwnedPackages.cmake </div><div class="line">&gt;git commit . -m&quot;Add auto generated project files.&quot;</div></div><!-- fragment --><p>to add them to the repository.</p>
<h2><a class="anchor" id="BasicPackageFiles"></a>
5. Add the MyApp application package</h2>
<p>Our CI project is now ready. The only thing that is missing is some actual C++ code. In order to add some <em>payload</em> code, we add a package directly to the <em>MyCPFProject</em> repository. This is a package that creates an executable. Add the following file tree to the <em>Sources</em> directory.</p>
<div class="fragment"><div class="line">Sources</div><div class="line">│</div><div class="line">└───MyApp</div><div class="line">        CMakeLists.txt</div><div class="line">        function.cpp</div><div class="line">        function.h</div><div class="line">        main.cpp</div></div><!-- fragment --><p>The new files in the MyApp directory should have the following content.</p>
<h4>CMakeLists.txt</h4>
<div class="fragment"><div class="line"># file MyCPFProject/Sources/MyApp/CMakeLists.txt</div><div class="line"></div><div class="line">include(cpfAddPackage)</div><div class="line"></div><div class="line"># define namespace name for module</div><div class="line">set( PACKAGE_NAMESPACE ma )</div><div class="line"></div><div class="line">set( briefDescription &quot;A C++ command line application that prints a string.&quot; )</div><div class="line">set( longDescription &quot;The application is so small that it needs no long description&quot; )</div><div class="line"></div><div class="line">cpfInitPackageProject(</div><div class="line">    PACKAGE_NAME</div><div class="line">    ${PACKAGE_NAMESPACE}</div><div class="line">)</div><div class="line"></div><div class="line">set( PACKAGE_PRODUCTION_FILES</div><div class="line">    main.cpp</div><div class="line">    function.cpp</div><div class="line">    function.h</div><div class="line">)</div><div class="line"></div><div class="line">set( PACKAGE_LINKED_LIBRARIES</div><div class="line">)</div><div class="line"></div><div class="line">############################################## Add Package #################################</div><div class="line">cpfAddPackage( </div><div class="line">    PACKAGE_NAME            ${PACKAGE_NAME}</div><div class="line">    PACKAGE_NAMESPACE       ${PACKAGE_NAMESPACE}</div><div class="line">    TYPE                    CONSOLE_APP</div><div class="line">    BRIEF_DESCRIPTION       ${briefDescription}</div><div class="line">    LONG_DESCRIPTION        ${longDescription}</div><div class="line">    PRODUCTION_FILES        ${PACKAGE_PRODUCTION_FILES}</div><div class="line">    LINKED_LIBRARIES        ${PACKAGE_LINKED_LIBRARIES}</div><div class="line">)</div></div><!-- fragment --><ul>
<li><code>include(cpfAddPackage)</code>: Provides the <code>cpfInitPackageProject()</code> and <code>cpfAddPackage()</code> functions.</li>
<li><code>set( PACKAGE_NAMESPACE myapp )</code>: The package namespace should be a short abbreviation of the package name. It is used in multiple places.<ul>
<li>As a part of the generated EXPORT MACRO that is used to publish symbol names in shared libraries. This is only relevant if the package is a library.</li>
<li>As the namespace of exported CMake targets which is also only relevant for library packages.</li>
<li>It is recommended but not necessary that you use that name also as C++ namespace for all source files in the package. The generated version header file at least uses this namespace.</li>
</ul>
</li>
<li><code>set( briefDescription ...</code> and <code>set( longDescription ...</code>: The documentation pipeline will create an entry page for your packages documentation and fill it with the given strings.</li>
<li><code>cpfInitPackageProject()</code>: This function retrieves the current version number of your package from the repository. It also reads the directory name and writes it into <code>PACKAGE_NAME</code>. It also creates <code></code>.cmake and <code></code>.h files that provide CMake and C++ code with the current package version.</li>
<li><code>set( PACKAGE_PRODUCTION_FILES ...</code>: A list with the currently available source files of the package. This is a <code>CMakeLists.txt</code> file after all ;-).</li>
<li><code>set( PACKAGE_LINKED_LIBRARIES ...</code>: A list with targets on which the created package depends. For now we have no dependencies so the list is empty.</li>
<li><code>cpfAddPackage( ...</code>: This function creates the package project and all the custom targets that belong to a CPF package. The bigger part of <a class="el" href="../../da/daa/_c_p_f_c_make.html#CPFCMake">CPFCMake's</a> functionality lies beneath this function.</li>
</ul>
<h4>function.h</h4>
<div class="fragment"><div class="line"><span class="comment">// file MyCPFProject/Sources/MyApp/function.h</span></div><div class="line"></div><div class="line"><span class="preprocessor">#pragma once</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ma</div><div class="line">{</div><div class="line">    <span class="keywordtype">bool</span> <span class="keyword">function</span>();</div><div class="line">}</div></div><!-- fragment --><h4>function.cpp</h4>
<p>This is a simple C++ file that implements a function. It represents your C++ code.</p>
<div class="fragment"><div class="line"><span class="comment">// file MyCPFProject/Sources/MyApp/function.cpp</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;MyApp/function.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;MyApp/cpfPackageVersion_MyApp.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ma</div><div class="line">{</div><div class="line">    <span class="keywordtype">bool</span> <span class="keyword">function</span>()</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyApp (version &quot;</span> + getPackageVersion() + <span class="stringliteral">&quot;) greets the world!&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The file includes the generated file <code>cpfPackageVersion_MyApp.h</code> header which provides function <code>ma::getPackageVersion()</code> that returns the current version number. Note that the include directories and the project directory structure in the CPF is laid-out that all includes can uniformly be written with <code>#include &lt;package/file.h&gt;</code>. As recommended in the section for the <code>CMakeLists.txt</code> file we put our package functions into namespace <em>ma</em>.</p>
<h4>main.cpp</h4>
<div class="fragment"><div class="line"><span class="comment">// file MyCPFProject/Sources/MyApp/main.cpp</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;MyApp/function.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="../../d0/da6/namespace_c_p_f_machines_1_1deploy__githooks.html#a20eb8b6a1f9d5cc00629adf79cd27686">main</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> ma::function();</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The CPF expects the main function to be in the file <code>main.cpp</code>. In the case of a package that creates an executable, the CPF internally creates a static library that contains all sources except the <code>main.cpp</code> file. This is done to allow linking the complete functionality to a test executable that may also be created.</dd></dl>
<h3><a class="anchor" id="AddPackageToCIProject"></a>
Add the owned package to the CI project</h3>
<p>We now have to tell the CI-project that we added an <em>owned package</em>. We do this by adding <em>MyApp</em> to the <code>cpfOwnedPackages.cmake</code> file.</p>
<div class="fragment"><div class="line"># file MyCPFProject/Sources/cpfOwnedPackages.cmake</div><div class="line"></div><div class="line">set( CPF_OWNED_PACKAGES</div><div class="line">&quot;\</div><div class="line">MyApp;\</div><div class="line">&quot;</div><div class="line">CACHE STRING &quot;\</div><div class="line">The packages that are owned by this CI-project. \</div><div class="line">Packages must be sorted by their level in the dependency graph. \</div><div class="line">Lower level packages must come first.\</div><div class="line">&quot; FORCE )</div></div><!-- fragment --><p>Finally commit the new files to the repository by running:</p>
<div class="fragment"><div class="line">&gt;git add Sources/MyApp</div><div class="line">&gt;git commit . -m&quot;Add the MyApp package.&quot;</div></div><!-- fragment --><h3><a class="anchor" id="BuildTheSinglePackageProject"></a>
Build the project</h3>
<p>With all the files in place we can now generate and build the project. Note that you have to run a complete generate whenever you change the <code><a class="el" href="../../db/df3/cpf_owned_packages_8cmake.html">cpfOwnedPackages.cmake</a></code> file. A <em>complete</em> generate is executed when the configuration option is given to the <code><a class="el" href="../../d9/d12/2___generate_8py.html">2_Generate.py</a></code> script. After the re-generate you can build and run the application.</p>
<div class="fragment"><div class="line">&gt;2_Generate.py VS</div><div class="line">&gt;3_Make.py --target pipeline</div><div class="line">&gt;Generated\VS\BuildStage\Debug\MyApp\MyApp-debug</div><div class="line">MyApp (version 0.0.0.2-73cc-dirty) greets the world!</div></div><!-- fragment --><p>Your actual version number will be different and depends on the current state of your repository. You can read more about the CPF versioning <a class="el" href="../../d3/dae/_c_p_f_versioning.html">here</a>. The pipeline target will also generate the documentation web-page. To take a look at it open the file <code>MyCPFProject/Generated/VS/html/doxygen/index.html</code>. In the <em>Modules</em> tab you will find a section for <em>MyApp</em>. If you follow the link you can see the automatically generated package main page that contains the package descriptions from the <code>CMakeLists.txt</code> file. The links in the lower part will not work, because our project does not generate the linked pages.</p>
<h2><a class="anchor" id="AddProjectConfig"></a>
6. Add a default configuration</h2>
<p>For our first build we used one of the default configurations that come with the CPF, <em>Linux</em> or <em>Windows</em>. You can find more detailed information about configurations in the CPF <a class="el" href="../../d7/d8d/_c_p_f_configuration.html">here</a>. In this section we add our own default configuration to the project. For demonstration purposes we change the configuration to build shared libraries instead of static libraries. To create the new default configuration execute the following steps.</p>
<div class="fragment"><div class="line">&gt;1_Configure.py VS2017-shared --inherits Windows -D BUILD_SHARED_LIBS=ON</div><div class="line">&gt;mkdir Sources\CIBuildConfigurations</div><div class="line">&gt;move Configuration\VS2017-shared.config.cmake Sources\CIBuildConfigurations</div><div class="line">&gt;rmdir /s /q Configuration</div><div class="line">&gt;1_Configure.py VS --inherits VS2017-shared</div><div class="line">&gt;2_Generate.py VS</div><div class="line">&gt;git add Sources\CIBuildConfigurations</div><div class="line">&gt;git commit . -m&quot;Add default configuration VS2017-shared.&quot;</div></div><!-- fragment --><ul>
<li>First we create a new configuration file that sets a different value for variable <code>BUILD_SHARED_LIBS</code>. This variable is used to tell CMake to build shared libraries instead of static ones. For now this has no effect because we have no library packages yet. Instead of using the <code>-D</code> command line options, you can also edit the configuration file with a text-editor, which may be more comfortable if multiple values are changed.</li>
<li>Then we move the new configuration to the projects default configurations directory <code>Sources/CIBuildConfigurations</code>.</li>
<li>With the second configure step we use the new default configuration as our new local <em>VS</em> configuration.</li>
<li>When making changes to our configuration, we have to do a fresh generate.</li>
<li>At the end we commit the new configuration file to the repository.</li>
</ul>
<p>Developers can now use the default configuration of the project without the need of manually setting any CMake variables.</p>
<h2><a class="anchor" id="CPFAddALibraryPackage"></a>
7. Add the library package MyLib</h2>
<p>As your C++ project grows, it will at some point become reasonable to split it into multiple libraries. With the CPF we create libraries by adding a library package. In this example we assume that our library will be used by other projects. To Allow this, we create a separate repository for the library package. We then add this repository as a git submodule to our <em>MyCPFProject</em> repository. If you do not know if a library will be shared between projects, you can first add it directly to the CI repository to avoid the extra overhead of working with a git submodule. If need be, you can still put it in it's own repository later.</p>
<p>Create a new repository with the name <em>MyLib</em> using the same steps that you executed when creating the <em>MyCPFProject</em> repository. You should end up with two empty repositories, <em>MyLib.git</em> and <em>MyLib</em>. Both lie besides the <em>MyCPFProject.git</em> and <em>MyCPFProject</em> directories. We will first add some files to the <em>MyLib</em> repository and then add it as git submodule to <em>MyCPFPRoject</em>.</p>
<h3><a class="anchor" id="CPFAddBasicLibPackageContent"></a>
Add content to the MyLib repository</h3>
<p>Add the following text-files to the <em>MyLib</em> repository and set the content as listed in the sections below.</p>
<div class="fragment"><div class="line">MyLib</div><div class="line">    CMakeLists.txt</div><div class="line">    function.cpp</div><div class="line">    function.h</div><div class="line">    .gitignore</div></div><!-- fragment --><h4>CMakeLists.txt</h4>
<div class="fragment"><div class="line"># file MyLib/CMakeLists.txt</div><div class="line"></div><div class="line">include(cpfAddPackage)</div><div class="line"></div><div class="line"># define namespace name for module</div><div class="line">set( PACKAGE_NAMESPACE ml )</div><div class="line"></div><div class="line">set( briefDescription &quot;A C++ library that prints a string.&quot; )</div><div class="line">set( longDescription &quot;The library is so small that it needs no long description&quot; )</div><div class="line"></div><div class="line">cpfInitPackageProject(</div><div class="line">    PACKAGE_NAME</div><div class="line">    ${PACKAGE_NAMESPACE}</div><div class="line">)</div><div class="line"></div><div class="line">set( PACKAGE_PUBLIC_HEADERS</div><div class="line">    function.h</div><div class="line">)</div><div class="line"></div><div class="line">set( PACKAGE_PRODUCTION_FILES</div><div class="line">    function.cpp</div><div class="line">)</div><div class="line"></div><div class="line">set( PACKAGE_LINKED_LIBRARIES</div><div class="line">)</div><div class="line"></div><div class="line">############################################## Add Package #################################</div><div class="line">cpfAddPackage( </div><div class="line">    PACKAGE_NAME            ${PACKAGE_NAME}</div><div class="line">    PACKAGE_NAMESPACE       ${PACKAGE_NAMESPACE}</div><div class="line">    TYPE                    LIB</div><div class="line">    BRIEF_DESCRIPTION       ${briefDescription}</div><div class="line">    LONG_DESCRIPTION        ${longDescription}</div><div class="line">    PUBLIC_HEADER           ${PACKAGE_PUBLIC_HEADERS}</div><div class="line">    PRODUCTION_FILES        ${PACKAGE_PRODUCTION_FILES}</div><div class="line">    LINKED_LIBRARIES        ${PACKAGE_LINKED_LIBRARIES}</div><div class="line">)</div></div><!-- fragment --><p>This file has some differences compared to the <code>MyApp\CMakeLists.txt</code> file.</p>
<ul>
<li>We changed the name of the namespace and the description of the package.</li>
<li>We changed the <code>TYPE</code> argument in the <code>cofAddPackage()</code> call in order to create a library package.</li>
<li>We added the <code>PUBLIC_HEADER</code> argument to the <code>cofAddPackage()</code> call. Libraries must provide public headers for consumers. With the argument we can say which of our headers are supposed to be public. Each library needs at least one public header or the project will fail to build.</li>
</ul>
<h4>function.h</h4>
<div class="fragment"><div class="line"><span class="comment">// file MyLib/function.h</span></div><div class="line"></div><div class="line"><span class="preprocessor">#pragma once</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;MyLib/ml_export.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ml</div><div class="line">{</div><div class="line">    ML_EXPORT <span class="keywordtype">bool</span> <span class="keyword">function</span>();</div><div class="line">}</div></div><!-- fragment --><p>Note the use of the <code>ML_EXPORT</code> export macro. The macro is provided by the <code>ml_export.h</code> header which is generated by CMake. Export macros are normally only needed when building shared libraries. However, it is good practice to let the clients of a library decide whether they want to use it as a shared or static a library. So better make sure that you always add the export macro to symbols that are intended to be used by clients. If you do not add the macro in a shared library, you will get linker errors.</p>
<h4>function.cpp</h4>
<div class="fragment"><div class="line"><span class="comment">// file MyLib/function.cpp</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;MyLib/function.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;MyLib/cpfPackageVersion_MyLib.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ml</div><div class="line">{</div><div class="line">    <span class="keywordtype">bool</span> <span class="keyword">function</span>()</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyLib (version &quot;</span> + getPackageVersion() + <span class="stringliteral">&quot;) greets the world!&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h4>.gitignore</h4>
<p>The package repository needs its own <code></code>.gitignore file. Add one with the following content:</p>
<div class="fragment"><div class="line"># file MyLib/.gitignore</div><div class="line">cpfPackageVersion_*</div></div><!-- fragment --><p>Now add, commit and push all files in the <em>MyLib</em> repository. We also add an initial version tag for the <em>MyLib</em> repository.</p>
<div class="fragment"><div class="line">MyLib&gt;git add .</div><div class="line">MyLib&gt;git commit . -m&quot;Add package files&quot;</div><div class="line">MyLib&gt;git tag -a 0.0.0 -m&quot;The initial version&quot;</div><div class="line">MyLib&gt;git push --all</div><div class="line">MyLib&gt;git push --tags</div></div><!-- fragment --><h3><a class="anchor" id="CPFAddLibPackageToProject"></a>
Add the MyLib package to the MyCPFProject repository.</h3>
<p>Now add <em>MyLib</em> as a <em>loose owned package</em> to <em>MyCPFProject</em> as a git submodule by running</p>
<div class="fragment"><div class="line">.../MyCPFProjec/Sources&gt;git submodule add &lt;your full path&gt;/MyLib.git</div></div><!-- fragment --><p>in the <code>MyCPFProject/Sources</code> directory. This will yield a <em>MyCPFPRoject/Sources/MyLib</em> directory that contains the files that you created in the above section. To finish the process edit some files in <em>MyCPFPRoject</em>.</p>
<h4>cpfOwnedPackages.cmake</h4>
<p>We add the <em>MyLib</em> package as owned package to CI project by adding it in the <code>cpfOwnedPackages.cmake</code> file. As the variable description states, it is essential that <em>MyLib</em> is added to the list before <em>MyApp</em>.</p>
<div class="fragment"><div class="line"># file MyCPFProject/Sources/cpfOwnedPackages.cmake</div><div class="line"></div><div class="line">set( CPF_OWNED_PACKAGES</div><div class="line">&quot;\</div><div class="line">MyLib;\</div><div class="line">MyApp;\</div><div class="line">&quot;</div><div class="line">CACHE STRING &quot;\</div><div class="line">The packages that are owned by this CI-project. \</div><div class="line">Packages must be sorted by their level in the dependency graph. \</div><div class="line">Lower level packages must come first.\</div><div class="line">&quot; FORCE )</div></div><!-- fragment --><h4>MyApp/CMakeLists.txt</h4>
<p>To make the functionality of <em>MyLib</em> available in <em>MyApp</em>, we have to add it to the linked libraries of <em>MyApp</em>.</p>
<div class="fragment"><div class="line"># file MyCPFProject/Sources/MyApp/CMakeLists.txt</div><div class="line"></div><div class="line">...</div><div class="line">set(PACKAGE_LINKED_LIBRARIES</div><div class="line">    MyLib</div><div class="line">)</div><div class="line">...</div></div><!-- fragment --><h4>MyApp/function.cpp</h4>
<p>We extend our original <code>ma::function()</code> to also call the <code>ml::function()</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// file MyCPFProject/Sources/MyApp/function.cpp</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;MyApp/function.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;MyApp/cpfPackageVersion_MyApp.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;MyLib/function.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ma</div><div class="line">{</div><div class="line">    <span class="keywordtype">bool</span> <span class="keyword">function</span>()</div><div class="line">    {</div><div class="line">        ml::function();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;MyApp (version &quot;</span> + getPackageVersion() + <span class="stringliteral">&quot;) greets the world!&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>You now have to commit the changes to <em>MyCPFProject</em> and regenerate the make-files in order to finish adding the library package.</p>
<div class="fragment"><div class="line">&gt;git commit . -m&quot;Add MyLib submodule and use it in MyApp.&quot;</div><div class="line">&gt;2_Generate.py VS</div><div class="line">&gt;3_Make.py</div><div class="line">&gt;Generated\VS\BuildStage\Debug\MyApp\MyApp-debug.exe</div><div class="line">MyLib (version 0.0.0) greets the world!</div><div class="line">MyApp (version 0.0.0.3-3d31) greets the world!</div></div><!-- fragment --><p>You can see that <em>MyApp</em> successfully calls the new function from MyLib. Again, your version numbers will be different. MyLib has a different version then then MyApp because it lives in a different repository.</p>
<h2><a class="anchor" id="AddTests"></a>
8. Add a test-executable to MyLib</h2>
<p>The CPF packages are designed to create an extra executable that runs automated tests for the packages production code. This section will show you how to enable such a test executable for the <em>MyLib</em> package. Add the new file <em>MyLib_tests_main.cpp</em> to a new <em>Tests</em> directory with the content</p>
<div class="fragment"><div class="line"><span class="comment">// MyCPFProject/MyLib/Tests/MyLib_tests_main.cpp</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;MyLib/function.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="../../d0/da6/namespace_c_p_f_machines_1_1deploy__githooks.html#a20eb8b6a1f9d5cc00629adf79cd27686">main</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Run tests for MyLib&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <a class="code" href="../../d9/da1/namespace_c_p_f_tests_1_1run__tests.html#acda0a7de620580ae194a430c93844727">result</a> = ml::function();</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="../../d9/da1/namespace_c_p_f_tests_1_1run__tests.html#acda0a7de620580ae194a430c93844727">result</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In a real project you would probably use the main function that is provided by your test-framework instead of writing your own. Note that we placed the file into the arbitrary <em>Tests</em> subdirectory which allows us to keep some order in our package. Change the packages <code>CMakeLists.txt</code> file content to this:</p>
<div class="fragment"><div class="line"># file MyCPFProject/Sources/MyLib/CMakeLists.txt</div><div class="line"></div><div class="line">include(cpfAddPackage)</div><div class="line"></div><div class="line"># define namespace name for module</div><div class="line">set( PACKAGE_NAMESPACE ml )</div><div class="line"></div><div class="line">set( briefDescription &quot;A C++ library that prints a string.&quot; )</div><div class="line">set( longDescription &quot;The library is so small that it needs no long description&quot; )</div><div class="line"></div><div class="line">cpfInitPackageProject(</div><div class="line">    PACKAGE_NAME</div><div class="line">    ${PACKAGE_NAMESPACE}</div><div class="line">)</div><div class="line"></div><div class="line">set( PACKAGE_PUBLIC_HEADERS</div><div class="line">    function.h</div><div class="line">)</div><div class="line"></div><div class="line">set( PACKAGE_PRODUCTION_FILES</div><div class="line">    function.cpp</div><div class="line">)</div><div class="line"></div><div class="line">set( PACKAGE_TEST_FILES</div><div class="line">    Tests/MyLib_tests_main.cpp</div><div class="line">)</div><div class="line"></div><div class="line">set( PACKAGE_LINKED_LIBRARIES</div><div class="line">)</div><div class="line"></div><div class="line">set( PACKAGE_LINKED_TEST_LIBRARIES</div><div class="line">)</div><div class="line"></div><div class="line">############################################## Add Package #################################</div><div class="line">cpfAddPackage( </div><div class="line">    PACKAGE_NAME            ${PACKAGE_NAME}</div><div class="line">    PACKAGE_NAMESPACE       ${PACKAGE_NAMESPACE}</div><div class="line">    TYPE                    LIB</div><div class="line">    BRIEF_DESCRIPTION       ${briefDescription}</div><div class="line">    LONG_DESCRIPTION        ${longDescription}</div><div class="line">    PUBLIC_HEADER           ${PACKAGE_PUBLIC_HEADERS}</div><div class="line">    PRODUCTION_FILES        ${PACKAGE_PRODUCTION_FILES}</div><div class="line">    TEST_FILES              ${PACKAGE_TEST_FILES}</div><div class="line">    LINKED_LIBRARIES        ${PACKAGE_LINKED_LIBRARIES}</div><div class="line">    LINKED_TEST_LIBRARIES   ${PACKAGE_LINKED_TEST_LIBRARIES}</div><div class="line">)</div></div><!-- fragment --><p>We added two new lists, <code>PACKAGE_TEST_FILES</code> and <code>PACKAGE_LINKED_TEST_LIBRARIES</code> and handed them to the <code>cpfAddPackage()</code> function. The <code>PACKAGE_TEST_FILES</code> list should contain all source files that are used to build the test executable. the <code>PACKAGE_LINKED_TEST_LIBRARIES</code> list can be used to add linked libraries that are only used by the test executable. This could be a test-framework library for example. In this example our test executable does not depend on any other library so we leave this empty.</p>
<p>You can now build and run your test executable by calling: </p><div class="fragment"><div class="line">&gt;2_Generate.py</div><div class="line">&gt;3_Make.py --target runAllTests</div><div class="line">...</div><div class="line">Run tests for MyLib</div><div class="line"></div><div class="line">MyLib (version 0.0.0.0-dirty) greets the world!</div><div class="line">...</div></div><!-- fragment --><p>Somewhere in the output you should see the text output of the executable. Note that tests will not be re-run if you execute the build command a second time. You have to edit at least one source file of the package in order to outdate the test-run. If you then rebuild the <em>runAllTests</em> target it will automatically create new binaries and run the tests with those.</p>
<p>For more information about the test targets of a CPF package see: <a class="el" href="../../d1/d4f/_c_p_f_c_make_test_targets.html">Test targets</a></p>
<h2><a class="anchor" id="AddFixtures"></a>
9. Add a fixture library to MyLib</h2>
<p>When writing a lot of automated tests, it may become necessary to re-use test utility code from one package in another. This could be fake or mock classes that you provide to replace the real objects in tests. To make that possible, the CPF can create an extra <em>fixture</em> library per package that can contain reusable test code. To demonstrate this, add two files <code>function_fixture.h</code> and <code>function_fixture.cpp</code> to the MyLib package with the following content and add them to the <code>CMakeLists.txt</code> file as shown below.</p>
<h4>Sources/MyLib/Tests/function_fixture.h</h4>
<div class="fragment"><div class="line"><span class="comment">// MyCPFProject/Sources/MyLib/Tests/function_fixture.h</span></div><div class="line"></div><div class="line"><span class="preprocessor">#pragma once</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;MyLib/ml_tests_export.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ml</div><div class="line">{</div><div class="line">    ML_TESTS_EXPORT <span class="keywordtype">void</span> prepareFunctionTest();</div><div class="line">}</div></div><!-- fragment --><ul>
<li>Note that the fixture library uses a different export macro then the production library.</li>
</ul>
<h4>Sources/MyLib/Tests/function_fixture.cpp</h4>
<div class="fragment"><div class="line"><span class="comment">// MyCPFProject/Sources/MyLib/Tests/function_fixture.cpp</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;MyLib/Tests/function_fixture.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ml</div><div class="line">{</div><div class="line">    <span class="keywordtype">void</span> prepareFunctionTest()</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Do reusable test preparations here&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h4>Sources/MyLib/CMakeLists.txt</h4>
<p>For the fixture library we have to distinguish between public header files and other source files. Add the new files to new list variables and as arguments to the <code>cpfAddPackage()</code> call as shown below.</p>
<div class="fragment"><div class="line"># file MyCPFProject/Sources/MyLib/CMakeLists.txt</div><div class="line">...</div><div class="line">set( PACKAGE_PUBLIC_FIXTURE_HEADER</div><div class="line">    Tests/function_fixture.h</div><div class="line">)</div><div class="line"></div><div class="line">set( PACKAGE_FIXTURE_FILES</div><div class="line">    Tests/function_fixture.cpp</div><div class="line">)</div><div class="line">...</div><div class="line"></div><div class="line">cpfAddPackage( </div><div class="line">    PACKAGE_NAME            ${PACKAGE_NAME}</div><div class="line">    PACKAGE_NAMESPACE       ${PACKAGE_NAMESPACE}</div><div class="line">    TYPE                    LIB</div><div class="line">    BRIEF_DESCRIPTION       ${briefDescription}</div><div class="line">    LONG_DESCRIPTION        ${longDescription}</div><div class="line">    PUBLIC_HEADER           ${PACKAGE_PUBLIC_HEADERS}</div><div class="line">    PRODUCTION_FILES        ${PACKAGE_PRODUCTION_FILES}</div><div class="line">    TEST_FILES              ${PACKAGE_TEST_FILES}</div><div class="line">    PUBLIC_FIXTURE_HEADER   ${PACKAGE_PUBLIC_FIXTURE_HEADER}</div><div class="line">    FIXTURE_FILES           ${PACKAGE_FIXTURE_FILES}</div><div class="line">    LINKED_LIBRARIES        ${PACKAGE_LINKED_LIBRARIES}</div><div class="line">    LINKED_TEST_LIBRARIES   ${PACKAGE_LINKED_TEST_LIBRARIES}</div><div class="line">)</div></div><!-- fragment --><h4>Sources/MyLib/Tests/MyLib_tests_main.cpp</h4>
<p>Use the new function in the test code. The fixture library is called &lt;package&gt;_fixtures and is automatically linked to the test executable. If you need it in the tests of another package you have to add it to that packages <code>PACKAGE_LINKED_TEST_LIBRARIES</code> variable.</p>
<div class="fragment"><div class="line"><span class="comment">// file MyCPFProject/Sources/MyLib/Tests/MyLib_tests_main.cpp</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;MyLib/function.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;MyLib/Tests/function_fixture.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="../../d0/da6/namespace_c_p_f_machines_1_1deploy__githooks.html#a20eb8b6a1f9d5cc00629adf79cd27686">main</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Run tests for MyLib&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    ml::prepareFunctionTest();</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <a class="code" href="../../d9/da1/namespace_c_p_f_tests_1_1run__tests.html#acda0a7de620580ae194a430c93844727">result</a> = ml::function();</div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="../../d9/da1/namespace_c_p_f_tests_1_1run__tests.html#acda0a7de620580ae194a430c93844727">result</a>)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    </div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="CPFCompileFixture"></a>
Compile and run the fixture code</h3>
<p>You can now compile and run your tests by calling</p>
<div class="fragment"><div class="line">&gt;3_Make.py --target runAllTests</div><div class="line">...</div><div class="line">Run tests for MyLib</div><div class="line"></div><div class="line">Do reusable test preparations here</div><div class="line">MyLib (version 0.0.0.2-6f37-dirty) greets the world!</div><div class="line">...</div></div><!-- fragment --><h2><a class="anchor" id="CPFAddDistributionPackages"></a>
10. Package the build results of MyLib</h2>
<p>One part of a CI pipeline is to create some sort of package that can be downloaded by the users of the software. For applications this is usually some sort of installer which can be arbitrarily complex. For libraries however, this is usually just a ZIP archive that either holds the complete source code or the compiled artifacts and public headers. In the CPF nomenclature we call these package files <em>distribution packages</em> in order to distinguish them from the CPF code packages in the <em>Sources</em> directory.</p>
<p>To enable creating distribution packages you have to add one more argument to the <code>cpfAddPackage()</code> function.</p>
<h4>Sources/MyLib/CMakeLists.txt</h4>
<div class="fragment"><div class="line"># file MyCPFProject/Sources/MyLib/CMakeLists.txt</div><div class="line">...</div><div class="line">set( archiveDevPackageOptions</div><div class="line">    DISTRIBUTION_PACKAGE_CONTENT_TYPE   BINARIES_DEVELOPER</div><div class="line">    DISTRIBUTION_PACKAGE_FORMATS        7Z TGZ</div><div class="line">)</div><div class="line">...</div><div class="line">cpfAddPackage( </div><div class="line">    PACKAGE_NAME            ${PACKAGE_NAME}</div><div class="line">    PACKAGE_NAMESPACE       ${PACKAGE_NAMESPACE}</div><div class="line">    TYPE                    LIB</div><div class="line">    BRIEF_DESCRIPTION       ${briefDescription}</div><div class="line">    LONG_DESCRIPTION        ${longDescription}</div><div class="line">    PUBLIC_HEADER           ${PACKAGE_PUBLIC_HEADERS}</div><div class="line">    PRODUCTION_FILES        ${PACKAGE_PRODUCTION_FILES}</div><div class="line">    TEST_FILES              ${PACKAGE_TEST_FILES}</div><div class="line">    PUBLIC_FIXTURE_HEADER   ${PACKAGE_PUBLIC_FIXTURE_HEADER}</div><div class="line">    FIXTURE_FILES           ${PACKAGE_FIXTURE_FILES}</div><div class="line">    LINKED_LIBRARIES        ${PACKAGE_LINKED_LIBRARIES}</div><div class="line">    LINKED_TEST_LIBRARIES   ${PACKAGE_LINKED_TEST_LIBRARIES}</div><div class="line">    DISTRIBUTION_PACKAGES   ${archiveDevPackageOptions}</div><div class="line">)</div></div><!-- fragment --><ul>
<li>Note that the <code>DISTRIBUTION_PACKAGES</code> argument requires a list of nested key-word arguments, due to the complexity of the option.</li>
<li>The options in this example will cause the creation of a <em>developer binary</em> package in the formats <code></code>.7z and <code></code>.tar.gz. Developer binary* means, that the package will contain the compiled binaries and public headers.</li>
<li>For more information about creating other kinds of distribution packages read: <a class="el" href="../../d3/d64/_c_p_f_distribution_packages.html">Distribution packages</a></li>
</ul>
<h3><a class="anchor" id="CPFBuildTheDistributionPackages"></a>
Create the distribution package</h3>
<p>In order to create the specified packages, run</p>
<div class="fragment"><div class="line">&gt;3_Make.py --target distributionPackages</div></div><!-- fragment --><p>You should now have a directory <code>MyCPFProject/Generated/VS/html/Downloads/MyLib/LastBuild</code> with the two packages <code>MyLib.&lt;version&gt;.Windows.dev-bin.Debug.7z</code> and <code>MyLib.&lt;version&gt;.Windows.dev-bin.Debug.tar.gz</code>. The packages are added to the html directory so they can be directly downloaded from the projects web-page.</p>
<h1><a class="anchor" id="CPFProjectSetupSummary"></a>
Summary</h1>
<p>You now know the basics about setting up a CPF project. If you still have open questions, feel free to ask them on the projects github page. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu May 10 2018 20:24:22 for CMakeProjectFramework by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
