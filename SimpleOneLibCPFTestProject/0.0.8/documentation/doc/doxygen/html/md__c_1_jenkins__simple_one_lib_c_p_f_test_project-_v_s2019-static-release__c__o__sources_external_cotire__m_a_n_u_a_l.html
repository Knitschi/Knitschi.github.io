<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SimpleOneLibCPFTestProject: cotire manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="SimpleOneLibCPFTestProject"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="DoxygenStylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SimpleOneLibCPFTestProject
   </div>
   <div id="projectbrief">A CPF Test project.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__c_1_jenkins__simple_one_lib_c_p_f_test_project-_v_s2019-static-release__c__o__sources_external_cotire__m_a_n_u_a_l.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">cotire manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Cotire (compile time reducer) is a CMake module that speeds up the build process of CMake based build systems by fully automating techniques as <a href="https://en.wikipedia.org/wiki/Precompiled_header">precompiled header</a> usage and <a href="https://en.wikipedia.org/wiki/Single_Compilation_Unit">single compilation unit</a> builds for C and C++.</p>
<h1>motivation </h1>
<p>Cotire was born out of a dissatisfaction with the existing CMake solutions for adding <a href="https://cmake.org/Bug/view.php?id=1260">precompiled header</a> support and unity build support to CMake based build systems. The design of cotire tries to adhere to the following principles:</p>
<h3>as automatic as possible</h3>
<p><a href="https://en.wikipedia.org/wiki/Precompiled_header">Precompiled header</a> and <a href="https://en.wikipedia.org/wiki/Single_Compilation_Unit">unity builds</a> are good ideas in principle, but in reality they do not work if the burden of maintaining the required additional source files (a <a href="https://en.wikipedia.org/wiki/Prefix_header">prefix header</a> and a unity source file) is put on the developer. A modern build system like CMake provides enough context information to have the build system generate and update these files automatically.</p>
<h3>non-intrusive</h3>
<p>The configuration of precompiled headers usage and single computation unit builds belongs to the build system and not in the source code. Nobody wants to litter one's source files with <code>hdrstop</code> pragmas or be forced to add an include directive to every file. Source code should build properly when a precompiled header isn't used and should build faster when a precompiled header is used.</p>
<h3>minimal interface</h3>
<p>Maintaining a build system over time is enough work and the CMake language may often get in your way. Thus the solution should only add few public CMake functions. It should be easy to integrate it into an existing CMake based build system and it should be just as easy to remove it again.</p>
<h3>lazy file creation</h3>
<p>The additional source files needed for precompiled header support and unity build support should only be created when they are required for the compilation of a target. Thus the solution should not create these files upon configuring the project, but should set up custom build commands for the creation of these files that only kick in when the files are required to exist by the build process.</p>
<h3>cross-platform</h3>
<p>C/C++ Compilers and IDEs on different platforms vary widely in how the implement precompiled header support. The solution should hide these implementation details and present a uniform interface to the developer on all supported platforms.</p>
<h1>cotire basic usage </h1>
<p>Cotire consists of a single CMake module file, which can be easily added to an existing CMake project.</p>
<p>The file <code>CMake/cotire.cmake</code> needs to be copied to the module directory of a CMake project. In the top-level <code>CMakeList.txt</code> file, the module directory needs to be added to the CMake module search path: </p><pre class="fragment">set (CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/CMake")
</pre><p>To use cotire in a CMake project, one adds the following include directive to the beginning of the top-level <code>CMakeList.txt</code>: </p><pre class="fragment">include(cotire)
</pre><p>To speed the build process of a CMake library or executable target, the <code>cotire</code> function is applied to a CMake target. From the example project that ships with cotire: </p><pre class="fragment">add_executable(example main.cpp example.cpp log.cpp log.h example.h)
...
cotire(example)
</pre><p>Cotire looks at the properties of the target provided by CMake (e.g., target type, source files, compile flags, preprocessor defines, include directories, ...) and modifies the target's build process in the following way:</p>
<ol type="1">
<li>cotire adds a custom build rule to produce a unity source file from the target's sources.</li>
<li>cotire adds a custom build rule to produce a prefix header file by tracking the header files included by the target's sources.</li>
<li>cotire adds a custom build rule to produce a precompiled header from the prefix header.</li>
<li>cotire modifies the target's compile flags to make use of the generated precompiled header.</li>
<li>cotire adds a couple of new targets.</li>
</ol>
<p>For makefile based build systems, running <code>make help</code> in the terminal reveals the new targets: </p><pre class="fragment">$ make help
...
... all_pch
... all_unity
... clean_cotire
... example
... example_pch
... example_unity
</pre><p>The <code>example_pch</code> target triggers the compilation of the precompiled header and as a side effect the generation of the unity source and the prefix header. The target <code>clean_cotire</code> cleans up all files generated by cotire. The <code>example_unity</code> target produces the same output as the original <code>example</code> target, but does so by performing a unity build. The <code>all_pch</code> and <code>all_unity</code> serve as pool targets for all cotired project targets.</p>
<p>By default, the <code>example_unity</code> target inherits all build settings from the original target <code>example</code> including linked libraries and target dependencies.</p>
<h1>cotire generated files </h1>
<p>For a target that has been cotired, three files will be generated as part of the build process:</p>
<h2>the unity source</h2>
<p>The unity source file is generated from the target by querying the target's <code>SOURCES</code> property. It consists of preprocessor include directives for each of the target source files. The files are included in the same order that is used in the CMake <code>add_executable</code> or <code>add_library</code> call. Header files are omitted.</p>
<p>This is a unity source generated for the example project under OS X: </p><pre class="fragment">#ifdef __cplusplus
#include "/Users/sakra/Documents/cotire/src/main.cpp"
#include "/Users/sakra/Documents/cotire/src/example.cpp"
#include "/Users/sakra/Documents/cotire/src/log.cpp"
#endif
</pre><p>The unity source file uses absolute paths to include the target's source file. The file is not intended to be portable across different build folders or machines. It is an intermediate file tied to the build folder that is automatically recreated by the build system if it is missing.</p>
<p>For multi-core machines cotire can be configured to generate multiple unity file segments that can be built in parallel by the chosen CMake generator (see below).</p>
<h2>the prefix header</h2>
<p>The prefix header is produced from the unity source file by running the unity file through the preprocessor and keeping track of each header file used (this is done by using option <code>-H</code> with GCC / Clang and <code>/showIncludes</code> with Visual Studio C++). The path of each used header file is compared against an exclude directory list and an include directory list to decide if the header file should be added to the prefix header.</p>
<p>By default the include directory list is empty and the exclude directory list is initialized to <code>"${CMAKE_SOURCE_DIR};${CMAKE_BINARY_DIR}"</code>. This default setting guarantees that project headers which are likely to be changed frequently are not added to the prefix header.</p>
<p>Upon generation of the prefix header cotire makes sure that target compile options, include path settings and preprocessor defines (e.g., <code>NDEBUG</code>) that affect the outcome of the preprocessor are correctly set up.</p>
<p>Generating the prefix header from the unity source is much faster than running each individual target source file through the preprocessor, because the coalesced unity source will make the preprocessor process most header files only once.</p>
<p>This is a prefix header produced for the example project with Visual Studio 2013 under Windows 7: </p><pre class="fragment">#pragma warning(push, 0)
#ifdef __cplusplus
#include "C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\include\string"
#include "C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\include\algorithm"
#include "C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\include\iostream"
#endif
#pragma warning(pop)
</pre><p>Generating the prefix file under Ubuntu 12.04 with GCC 4.6 yields the following result: </p><pre class="fragment">#pragma GCC system_header
#ifdef __cplusplus
#include "/usr/include/c++/4.6/string"
#include "/usr/include/c++/4.6/algorithm"
#include "/usr/include/c++/4.6/iterator"
#include "/usr/include/c++/4.6/iostream"
#endif
</pre><p>Using Xcode 5.1 under OS X 10.9, this is the resulting prefix header: </p><pre class="fragment">#pragma clang system_header
#ifdef __cplusplus
#include "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/c++/v1/string"
#include "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/c++/v1/iostream"
#endif
</pre><p>Besides include directives, cotire also adds compiler specific pragmas to the generated prefix header to suppress compiler warnings upon inclusion.</p>
<p>Cotire attempts to produce a minimal list of header files by omitting header files indirectly included by a header that is already part of the prefix header. Header files with nonstandard file extensions like <code>.inl</code>, <code>.inc</code> of <code>.ipp</code> are omitted by default.</p>
<p>The generated prefix file includes the selected header files by their absolute paths. This speeds up the precompiling of the prefix header because the compiler does not have to search for header files in include directories again.</p>
<p>The prefix header is tailored to the CMake target that it is generated for. It is tied to the compiler environment of the local machine and is not portable across different compilers or machines. It is automatically recreated by the build system if it goes missing.</p>
<p>The generated prefix header can be applied to a different target added in the same source directory (see below).</p>
<p>Optionally, cotire will also create a prefix source file that consists of a single include directive for the prefix header. This file is needed for pre-compiling the prefix header with Clang or GCC to make both compilers handle the <code>system_header</code> pragma correctly.</p>
<h2>the precompiled header</h2>
<p>The precompiled header is produced from the generated prefix header by using the proprietary precompiling mechanism depending on the compiler used. For GCC and Clang cotire sets up a custom build rule and generates the precompiled header as described in the documentation for <a href="https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html">GCC</a> and <a href="https://clang.llvm.org/docs/UsersManual.html#precompiled-headers">Clang</a>. Cotire then modifies the <code>COMPILE_FLAGS</code> property of the target to force the inclusion of the prefix header.</p>
<p>Visual Studio C++ and Intel C++ use a <a href="https://msdn.microsoft.com/en-us/library/szfdksca(v=vs.90).aspx">different approach</a> to pre-compiling. Both compilers require a host source file to generate the precompiled header as a side effect of producing an object file. Cotire modifies the <code>COMPILE_FLAGS</code> of the first target source file to <a href="https://msdn.microsoft.com/en-us/library/7zc28563(v=vs.90).aspx">generate</a> the precompiled header and then modifies the <code>COMPILE_FLAGS</code> of the remaining target source files to <a href="https://msdn.microsoft.com/en-us/library/z0atkd6c(v=vs.90).aspx">include</a> the generated precompiled header.</p>
<p>For Xcode projects generated with CMake, cotire completely hands off the pre-compilation of the prefix header and the inclusion of the precompiled header to the IDE. Cotire attaches a pre-build action to the target which generates the unity source file and the prefix header. Cotire then modifies Xcode attributes of the generated Xcode project to have Xcode precompile the the generated prefix header with the Xcode build steps <code>ProcessPCH</code> for C sources and <code>ProcessPCH++</code> for C++ sources.</p>
<p>For precompiled headers creation flags must match use flags exactly. Cotire uses the same flags, include directories and preprocessor defines that are used for the compilation of source files for the generation of the precompiled header. Thus the resulting precompiled header binary is only usable for the target and cannot be re-used for a different CMake target.</p>
<h1>cotire advanced usage </h1>
<h2>applying cotire to multiple targets at the same time</h2>
<p>The <code>cotire</code> function can be applied to multiple targets added in the same source directory in one call: </p><pre class="fragment">add_library(libA STATIC ...)
add_library(libB SHARED ...)
add_executable(example ...)
...
cotire(example libA libB)
</pre><h2>mixed-language targets</h2>
<p>Cotire is able to speed up the build process of mixed language targets, consisting of both C and C++ sources. It generates a separate set of unity source files, prefix headers and precompiled headers for both languages and modifies the <code>COMPILE_FLAGS</code> of each target source file to include the correct precompiled header depending on the compilation language of the source file.</p>
<h2>obtaining the names of the generated files and targets</h2>
<p>For a cotired target the target properties <code>COTIRE_&lt;LANG&gt;_UNITY_SOURCE</code>, <code>COTIRE_&lt;LANG&gt;_PREFIX_HEADER</code>, <code>COTIRE_&lt;LANG&gt;_PRECOMPILED_HEADER</code> will be set to the paths of the generated files (<code>&lt;LANG&gt;</code> can be set to <code>CXX</code> or <code>C</code>). The target property <code>COTIRE_UNITY_TARGET_NAME</code> will be set to the name of the generated unity target: </p><pre class="fragment">cotire(example)
...
get_target_property(_unitySource example COTIRE_CXX_UNITY_SOURCE)
get_target_property(_prefixHeader example COTIRE_CXX_PREFIX_HEADER)
get_target_property(_precompiledHeader example COTIRE_CXX_PRECOMPILED_HEADER)
get_target_property(_unityTargetName example COTIRE_UNITY_TARGET_NAME)
</pre><p>If a source file's <code>COMPILE_FLAGS</code> are modified by cotire, it sets the source file property <code>COTIRE_TARGET</code> to the name of the target, that the source file's build command has been altered for: </p><pre class="fragment">cotire(example)
...
get_source_file_property(_cotireTargetName "example.cpp" COTIRE_TARGET)
if (_cotireTargetName)
    message(STATUS "example.cpp has been cotired for target ${_cotireTargetName}")
endif()
</pre><h2>changing the name of the generated unity build target</h2>
<p>By default cotire uses the name of the the original target with the suffix <code>_unity</code> appended for the name of the generated unity build target. To create the unity build target under a different name, set the <code>COTIRE_UNITY_TARGET_NAME</code> property: </p><pre class="fragment">add_executable(example_template main.cpp example.cpp log.cpp log.h example.h)
set_target_properties(example_template PROPERTIES COTIRE_UNITY_TARGET_NAME "example")
...
cotire(example_template)
</pre><p>Invoking the <code>example</code> target will then run the unity build.</p>
<h2>restricting cotire to certain build configurations</h2>
<p>To restrict the cotire related modifications to the build process to certain build configurations, the <code>CONFIGURATIONS</code> parameter can be added to the <code>cotire</code> call. </p><pre class="fragment">cotire(example CONFIGURATIONS Release MinSizeRel)
</pre><p>For single build type builds the selected configuration will be checked at configure time, for multi-configuration builds the check will be done at build time.</p>
<p>It is recommended to have at least one build configuration that does not make use of cotire to ensure that the project builds properly without cotire.</p>
<h2>disabling precompiled headers and unity builds</h2>
<p>If the target's build process should not be modified to make use of the generated precompiled header, the target property <code>COTIRE_ENABLE_PRECOMPILED_HEADER</code> can be set to <code>FALSE</code>: </p><pre class="fragment">set_target_properties(example PROPERTIES COTIRE_ENABLE_PRECOMPILED_HEADER FALSE)
cotire(example)
</pre><p>If a unity build target should not be added by cotire, the target property <code>COTIRE_ADD_UNITY_BUILD</code> can be set to <code>FALSE</code>: </p><pre class="fragment">set_target_properties(example PROPERTIES COTIRE_ADD_UNITY_BUILD FALSE)
cotire(example)
</pre><p>The property <code>COTIRE_ADD_UNITY_BUILD</code> only affects the addition of the unity build target. Custom build rules for the generation of the unity source file will always be set up, because the unity source file is needed for the generation of the prefix header.</p>
<p>Both properties default to <code>TRUE</code>. If both are set to <code>FALSE</code>, cotire will only set up custom build rules for the generation of the unity source and the prefix header.</p>
<p>The properties <code>COTIRE_ENABLE_PRECOMPILED_HEADER</code> and <code>COTIRE_ADD_UNITY_BUILD</code> can also be set on directories. A target inherits the property value from its enclosing directory.</p>
<h2>disabling precompiled headers for small targets</h2>
<p>The cache variable <code>COTIRE_MINIMUM_NUMBER_OF_TARGET_SOURCES</code> can be set to the minimum number of source files required to enable the use of a precompiled header. It defaults to 2. To override the default, run <code>cmake</code> with the following options: </p><pre class="fragment">$ cmake -D COTIRE_MINIMUM_NUMBER_OF_TARGET_SOURCES=5 &lt;path-to-source&gt;
</pre><h2>using a manually maintained prefix header instead of the automatically generated one</h2>
<p>cotire can be configured to use an existing manually maintained prefix header (e.g., Visual Studio projects often use a prefix header named <code>stdafx.h</code>) instead of the automatically generated one. Set the target property <code>COTIRE_CXX_PREFIX_HEADER_INIT</code> to the path of the existing prefix header file. The path is interpreted relative to the target source directory: </p><pre class="fragment">set_target_properties(example PROPERTIES COTIRE_CXX_PREFIX_HEADER_INIT "stdafx.h")
cotire(example)
</pre><p>If the prefix header <code>stdafx.h</code> needs an accompanying source file (e.g., <code>stdafx.cpp</code>) in order to be precompiled properly, that source file needs to be the first one on the list of source files in the target's <code>add_executable</code> or <code>add_library</code> call.</p>
<p>The property <code>COTIRE_CXX_PREFIX_HEADER_INIT</code> can also be set to a list of header files which will then make up the contents of the generated prefix header.</p>
<p>A manually maintained prefix header will always be applied to the corresponding target, even if the target contains too few sources to enable the use of a precompiled header.</p>
<h2>using a generated prefix header for multiple targets</h2>
<p>A prefix header that is generated for a cotired target can be applied to a different target added in the same source directory: </p><pre class="fragment">cotire(example)
get_target_property(_prefixHeader example COTIRE_CXX_PREFIX_HEADER)
...
set_target_properties(other_target PROPERTIES COTIRE_CXX_PREFIX_HEADER_INIT "${_prefixHeader}")
cotire(other_target)
</pre><p>The compilation of either target will trigger the generation of the prefix header.</p>
<h2>configuring the generation of the prefix header</h2>
<p>There are multiple target properties which affect the generation of the prefix header:</p>
<ul>
<li><code>COTIRE_PREFIX_HEADER_IGNORE_PATH</code> can be set to a semicolon separated list of directories. If a header file is found in one of these directories or sub-directories, it will be excluded from the generated prefix header.</li>
<li><code>COTIRE_PREFIX_HEADER_INCLUDE_PATH</code> can be set to a semicolon separated list of directories. If a header file is included from one of these directories or sub-directories, it will be included in the generated prefix header.</li>
</ul>
<p>If a header file is matched by both <code>COTIRE_PREFIX_HEADER_IGNORE_PATH</code> and <code>COTIRE_PREFIX_HEADER_INCLUDE_PATH</code>, the option which yields the closer relative path match wins. For example, if third-party libraries are part of the source tree in a directory called <code>Libs</code>, the following setting will make cotire select header files from the third-party directory, but ignore other project related headers in <code>CMAKE_SOURCE_DIR</code>: </p><pre class="fragment">set_target_properties(example PROPERTIES
    COTIRE_PREFIX_HEADER_IGNORE_PATH "${CMAKE_SOURCE_DIR}"
    COTIRE_PREFIX_HEADER_INCLUDE_PATH "${CMAKE_SOURCE_DIR}/Libs")
</pre><p>The properties <code>COTIRE_PREFIX_HEADER_IGNORE_PATH</code> and <code>COTIRE_PREFIX_HEADER_INCLUDE_PATH</code> can also be set on directories.</p>
<p>The following cache variables also affect the selection of prefix headers:</p>
<ul>
<li>Directory paths in <code>COTIRE_ADDITIONAL_PREFIX_HEADER_IGNORE_PATH</code> will be added to the list of ignored directories when the prefix header file is created.</li>
<li><code>COTIRE_ADDITIONAL_PREFIX_HEADER_IGNORE_EXTENSIONS</code> can be used to ignore header files by file extension. It defaults to the CMake list <code>inc;inl;ipp</code>.</li>
</ul>
<p>During development, changes to the project source files may affect the list of header files that should be selected for inclusion in the prefix header (e.g., a standard include may be added or removed from a target source file). Cotire does not automatically recreate the prefix header, when a target source file is changed, because this would always trigger a re-compilation of the precompiled header and would result in a rebuild of the whole target. To make the prefix header creation dependent on changes to certain target source files, the source file property <code>COTIRE_DEPENDENCY</code> can be set to <code>TRUE</code> for those files: </p><pre class="fragment">set_property (SOURCE "example.cpp" PROPERTY COTIRE_DEPENDENCY "TRUE")
</pre><h2>fixing linkage issues</h2>
<p>When a C++ program uses <code>extern "C"</code> on a system header file, cotire will not be able to detect that the include file needs C linkage and will include the file with C++ linkage in the generated prefix header instead. For example, the C interface to BLAS <code>cblas.h</code> usually has to be included as <code>extern "C"</code> in a C++ program: </p><pre class="fragment">extern "C" {
#include &lt;cblas.h&gt;
}
</pre><p>The presence of <code>extern "C"</code> includes will prevent cotired targets from being linked successfully because of unresolved function references using the wrong linkage. To work around the problem, the property <code>COTIRE_PREFIX_HEADER_IGNORE_PATH</code> can also include the full path of header files besides directories. Here is an example: </p><pre class="fragment">set_property(DIRECTORY
    PROPERTY COTIRE_PREFIX_HEADER_IGNORE_PATH
        "${ATLAS_INCLUDE_DIR}/cblas.h"
        "${CMAKE_SOURCE_DIR}" "${CMAKE_BINARY_DIR}")
</pre><p>That way <code>cblas.h</code> will not be included in the generated prefix header and will not cause problems upon linking.</p>
<h2>using a manually maintained unity source instead of the automatically generated one</h2>
<p>Cotire can be configured to use an existing manually maintained unity source file instead of the automatically generated one. Set the target property <code>COTIRE_CXX_UNITY_SOURCE_INIT</code> to the path of the existing unity source file. Its path is interpreted relative to the target source directory: </p><pre class="fragment">set_target_properties(example PROPERTIES COTIRE_CXX_UNITY_SOURCE_INIT "example-all.cpp")
cotire(example)
</pre><p>The property can also be set to a list of source files which will then make up the contents of the generated unity source file.</p>
<h2>configuring the generation of the unity source</h2>
<p>By default cotire adds all target source files to the generated unity source. In most cases a unity build will not work out of the box, because unity builds <a href="http://altdevblog.com/2011/08/14/the-evils-of-unity-builds/">break</a> the use of some C and C++ language features. Unity build problems can be tackled in the following way:</p>
<ul>
<li>Change the order of the source files in the <code>add_executable</code> or <code>add_library</code> calls. Problematic source files should be moved towards the end.</li>
<li>Set the source file property <code>COTIRE_EXCLUDED</code> on problematic source files. The source file will not be included in the unity source file and will be compiled separately when the unity build is performed.</li>
<li><code>COTIRE_UNITY_SOURCE_EXCLUDE_EXTENSIONS</code> can be used to exclude source files by file extension from inclusion in the generated unity source. It defaults to the CMake list <code>m;mm</code>.</li>
<li>If the unity source file is too large and the compilation process runs into a compiler limit, the target property <code>COTIRE_UNITY_SOURCE_MAXIMUM_NUMBER_OF_INCLUDES</code> can be set. If the target contains more than that number of source files, cotire will create multiple unity source files for it. Each unity source file is compiled separately when the unity build is performed. The property is initialized by value of the cache variable <code>COTIRE_MAXIMUM_NUMBER_OF_UNITY_INCLUDES</code>.</li>
<li>Another way to break up a large unity source file is to set the source file property <code>COTIRE_START_NEW_UNITY_SOURCE</code> to <code>TRUE</code> on selected target source files. If cotire encounters this property, it will complete the current unity file and start a new one. The new unity source file will include the source file as the first one. This property essentially works as a separator for unity source files.</li>
</ul>
<h2>optimizing the build process for multiple processor cores</h2>
<p>To make use of all the machine's CPU cores for the unity compilation of a target, the target property <code>COTIRE_UNITY_SOURCE_MAXIMUM_NUMBER_OF_INCLUDES</code> can be set to the string <code>-j</code>. Cotire will then create as many unity file segments as there are CPU cores on the machine. Because the unity file segments do not depend on each other, a multi-core aware build process can compile the file segments in parallel.</p>
<p>To explicitly specify the number of cores, append the number after <code>-j</code>, e.g. <code>-j 4</code> or <code>-j4</code>.</p>
<p>For CMake generators that are multi-core aware by default (i.e., Visual Studio, JOM, Ninja), cotire will automatically initialize the property to <code>-j</code>. For makefile based generators, this has to be done explicitly by setting the cache variable <code>COTIRE_MAXIMUM_NUMBER_OF_UNITY_INCLUDES</code>, i.e.: </p><pre class="fragment">$ cmake -D COTIRE_MAXIMUM_NUMBER_OF_UNITY_INCLUDES=-j4 &lt;path-to-source&gt;
$ make -j 4
</pre><h2>fixing macro definition clashes</h2>
<p>Many unity build problems stem from macro definitions leaking into other target source files, where they may conflict with other definitions of the same name. Cotire adds the properties <code>COTIRE_UNITY_SOURCE_PRE_UNDEFS</code> and <code>COTIRE_UNITY_SOURCE_POST_UNDEFS</code> to fix macro definition clashes.</p>
<p>As an example, if these properties are set on a source file of the example project: </p><pre class="fragment">set_source_files_properties (example.cpp PROPERTIES
    COTIRE_UNITY_SOURCE_PRE_UNDEFS "max;min"
    COTIRE_UNITY_SOURCE_POST_UNDEFS "DEBUG_TYPE")
</pre><p>This will make cotire add undefs to the generated unity source file.</p>
<pre class="fragment">#ifdef __cplusplus
#include "/Users/sakra/Documents/cotire/src/main.cpp"
#undef min
#undef max
#include "/Users/sakra/Documents/cotire/src/example.cpp"
#undef DEBUG_TYPE
#include "/Users/sakra/Documents/cotire/src/log.cpp"
#endif
</pre><p>The properties <code>COTIRE_UNITY_SOURCE_PRE_UNDEFS</code> and <code>COTIRE_UNITY_SOURCE_POST_UNDEFS</code> can also be set on targets. Cotire will add</p><div class="fragment"><div class="line">#undef </div>
</div><!-- fragment --><p> directives for each source file in the unity source then.</p>
<h2>enabling verbose builds</h2>
<p>The cache variable <code>COTIRE_VERBOSE</code> can be set to <code>TRUE</code> to see all compile commands used when generating the cotire related files. Cotire will also print the contents of the generated unity source and the prefix header for verbose builds. <code>COTIRE_VERBOSE</code> defaults to <code>FALSE</code>. When using a Makefile generator <code>COTIRE_VERBOSE</code> defaults to the value of the makefile variable <code>VERBOSE</code> (i.e., <code>make VERBOSE=1</code>).</p>
<h2>conditionally loading cotire</h2>
<p>To make a <code>CMakeLists.txt</code> robust against a missing <code>cotire.cmake</code> module, the following strategy can be applied to using cotire: </p><pre class="fragment">include(cotire OPTIONAL)
...
add_executable(example main.cpp example.cpp log.cpp log.h example.h)
...
if (COMMAND cotire)
    cotire(example)
endif()
</pre><p>The <code>include(cotire OPTIONAL)</code> will prevent CMake from raising an error if cotire cannot be found. The actual calls to cotire need to be guarded by <code>if (COMMAND cotire)</code> blocks.</p>
<h2>using cotire with compiler wrappers</h2>
<p>Cotire is compatible with CMake compiler wrappers. For example, the use of <a href="https://ccache.samba.org/">ccache</a> may be enabled in the following way upon configuring the project: </p><pre class="fragment">$ export CC="/usr/local/bin/ccache /usr/bin/gcc"
$ export CXX="/usr/local/bin/ccache /usr/bin/g++"
$ export CCACHE_SLOPPINESS=pch_defines,time_macros
$ cmake ..
</pre><p>Alternatively, for CMake 3.4 or later compiler wrappers can be enabled by pointing the CMake variable <code>CMAKE_CXX_COMPILER_LAUNCHER</code> to the compiler wrapper executable upon configuring: </p><pre class="fragment">$ cmake -D CMAKE_CXX_COMPILER_LAUNCHER=/usr/local/bin/ccache &lt;path-to-source&gt;
</pre><p>Note that with ccache in order for precompiled headers to work properly, it is necessary to set the environment variable <code>CCACHE_SLOPPINESS</code> to <code>pch_defines,time_macros</code>. Otherwise the build process may abort with the following error message: </p><pre class="fragment">fatal error: file 'example_CXX_prefix.hxx' has been modified since the precompiled header
      'example_CXX_prefix.hxx.gch' was built
</pre><p>Also see the <a href="https://ccache.samba.org/manual.html#_precompiled_headers">ccache manual</a>.</p>
<h2>applying cotire to object library targets</h2>
<p>CMake 2.8.8 introduced a new type of library target called <a href="https://cmake.org/cmake/help/latest/command/add_library.html#object-libraries">object library</a>. An object library is a convenience target that compiles multiple source files but does not create a linked target library for them, e.g.: </p><pre class="fragment">add_library(myLib OBJECT lib1.cpp lib2.cpp lib3.cpp)
add_executable(exeA $&lt;TARGET_OBJECTS:myLib&gt; mainA.cpp)
add_executable(exeB $&lt;TARGET_OBJECTS:myLib&gt; mainB.cpp)
</pre><p>The <code>cotire</code> function can be applied to an object library target in a familiar fashion: </p><pre class="fragment">add_library(myLib OBJECT lib1.cpp lib2.cpp lib3.cpp)
cotire(myLib)
# use unity object library for executables
add_executable(exeA $&lt;TARGET_OBJECTS:myLib_unity&gt; mainA.cpp)
add_executable(exeB $&lt;TARGET_OBJECTS:myLib_unity&gt; mainB.cpp)
</pre><p>Because object library targets do not support <code>PRE_BUILD</code> actions, precompiled header usage cannot be enabled for them for Xcode projects generated with CMake. Unity builds work as expected, though.</p>
<h2>automatically setting up linked libraries in the unity target</h2>
<p>The setting of the target property <code>COTIRE_UNITY_LINK_LIBRARIES_INIT</code> controls the linking strategy for the generated unit target.</p>
<p>If this property is empty or set to <code>NONE</code>, the generated unity target's link libraries have to be set up manually with subsequent <code>target_link_libraries</code> calls: </p><pre class="fragment">set_target_properties(example PROPERTIES COTIRE_UNITY_LINK_LIBRARIES_INIT "NONE")
...
cotire(example)
target_link_libraries(MyExecutable_unity ${MyExecutableLibraries})
</pre><p>If this property is set to <code>COPY</code>, the unity target's link libraries will be copied from the original target.</p>
<p>If this property is set to <code>COPY_UNITY</code>, the unity target's link libraries will be copied from the original target but instead of copying a linked target verbatim, the target's corresponding unity target will be preferred, provided one exists. This also applies to object libraries, which have been added to the original target with a <code>TARGET_OBJECTS</code> generator expression.</p>
<p>As of cotire 1.7.0, the default linking strategy for unit targets is <code>COPY_UNITY</code>.</p>
<p>The property <code>COTIRE_UNITY_LINK_LIBRARIES_INIT</code> can also be set on directories. A target inherits the property value from its enclosing directory. To make all targets in the project use the <code>COPY</code> strategy, the directory property can be set in the outermost <code>CMakeList.txt</code> file: </p><pre class="fragment">include(cotire)
...
set_property(DIRECTORY PROPERTY COTIRE_UNITY_LINK_LIBRARIES_INIT "COPY")
</pre><h2>using cotire with Qt</h2>
<p>Cotire is compatible with both Qt projects that use CMake as build system, provided Qt targets do not use CMake automatic moc, uid or rcc scanning.</p>
<h2>installing files generated by unity targets</h2>
<p>Cotire cannot set up a <code>install_unity</code> target that mimics the <code>install</code> target automatically, because CMake does not provide the necessary information about the existing install rules programmatically.</p>
<p>When using a Makefile generator, you can use the following workaround (thanks to peterhuene): </p><pre class="fragment">$ make all_unity
$ make install/fast
</pre><p>The <code>install/fast</code> does not trigger a build, but will use the binaries built by the <code>all_unity</code> target.</p>
<p>For other generators, set up an <code>install_unity</code> target manually. First set up install rules for all unity targets, that mimic the install rules for the original targets: </p><pre class="fragment">install(TARGETS example_unity RUNTIME DESTINATION "bin" OPTIONAL COMPONENT "unity")
</pre><p>This installs the <code>example</code> executable built by the unity target to the <code>bin</code> folder. The install rules for unity targets must use a custom install component. Then add a global <code>install_unity</code> target that performs the installation of all unity targets: </p><pre class="fragment">add_custom_target(install_unity
    COMMAND ${CMAKE_COMMAND} -DCOMPONENT=unity -P cmake_install.cmake
    COMMENT "Install the unity-built project..."
    WORKING_DIRECTORY ${CMAKE_BINARY_DIR})
add_dependencies(unity_install example_unity)
</pre><p>The global <code>install_unity</code> target must depend on all unity targets that should be installed.</p>
<h2>customized inclusion of system headers</h2>
<p>If a system header ends up in a precompiled header, it is not possible to customize the inclusion of that header in a source file through preprocessor defines.</p>
<p>For example, under Windows one may want to include <code>Windows.h</code> with <code>NOMINMAX</code> defined to prevent the definition of the <code>min</code> and <code>max</code> macros: </p><pre class="fragment">#define NOMINMAX
#include &lt;Windows.h&gt;
</pre><p>The dependency of <code>Windows.h</code> on the preprocessor define <code>NOMINMAX</code> will not be picked up by cotire automatically upon adding <code>Windows.h</code> to the prefix header. To work around the problem, make the dependency explicit by using <code>add_definitions</code> in the corresponding <code>CMakeLists.txt</code>: </p><pre class="fragment">if (WIN32)
    # prevent definition of min and max macros through inclusion of Windows.h
    add_definitions("-DNOMINMAX")
endif()
</pre><p>That way, the preprocessor define <code>NOMINMAX</code> will be picked up by cotire and applied to the pre-compilation of the prefix header.</p>
<h2>organize includes added to the prefix header</h2>
<p>Sometimes the order of the includes in the automatically generated prefix header may result in compilation errors due to subtile header dependencies.</p>
<p>To work around the problem, the target property <code>COTIRE_PREFIX_HEADER_INCLUDE_PRIORITY_PATH</code> can be set to a list of directories. Header files whose path matches one of these directories will be inserted at the beginning of generated prefix header. Header files are sorted according to the order of the directories in the property. Headers not matching one of these directories are left untouched.</p>
<p>The property <code>COTIRE_PREFIX_HEADER_INCLUDE_PRIORITY_PATH</code> can also be set on directories. A target inherits the property value from its enclosing directory.</p>
<h1>common pitfalls </h1>
<h2>include the <code>cotire.cmake</code> module correctly</h2>
<p>If CMake issues the message <code>Unknown CMake command "cotire"</code>, double check that the cotire module has been included correctly in your project. See the manual section "cotire basic usage".</p>
<h2>do not modify a target's build related properties after applying cotire</h2>
<p>Cotire only considers build related settings of a target at the time of the <code>cotire</code> function call. If target properties that control the build are changed after the call to the <code>cotire</code> function, the build rules set up by cotire for the precompiled header and unity build may not work correctly.</p>
<p>Don't do this: </p><pre class="fragment">add_executable(example main.cpp example.cpp log.cpp log.h example.h)
cotire(example)
...
set_target_properties(example PROPERTIES POSITION_INDEPENDENT_CODE ON) # affects build
</pre><h2>always apply cotire in the same source directory where a target has been added</h2>
<p>CMake targets are globally visible. Nevertheless, it is important that the <code>cotire</code> function is called for a target in the exact same directory that creates the target with <code>add_library</code> or <code>add_executable</code>.</p>
<p>Don't do this: </p><pre class="fragment">add_subdirectory(src)
...
cotire(mytarget) # mytarget added in src directory
</pre><p>Cotire may fail to inspect the target's source files correctly, if the target has been added in a different directory and you may get odd messages about missing source files.</p>
<h1>known issues </h1>
<h2>generator expressions</h2>
<p>cotire uses the CMake command <code>file(GENERATE ...</code> to expand generator expressions used in various compilation settings. This command does not handle certain CMake generator expressions like <code>$&lt;CXX_COMPILER_ID:...&gt;</code> correctly.</p>
<h2>Ninja compatibility</h2>
<p>Under Ninja indirect prefix header dependencies are ignored by the generated build system. Cotire uses the <code>IMPLICIT_DEPENDS</code> option of <code>add_custom_command</code> to make the precompiled header depend on header files indirectly included by the prefix header. The <code>IMPLICIT_DEPENDS</code> option is not supported by CMake's Ninja generator. See <a href="https://cmake.org/Bug/view.php?id=13234">CMake issue</a>.</p>
<h2>using source files for multiple targets</h2>
<p>When the same set of source files is used for different targets (e.g., for producing a static and a shared library variant from the same sources), using a precompiled header may not work. Under certain circumstances, cotire cannot enable the precompiled header usage by changing the <code>COMPILE_FLAGS</code> property of the whole target, but must set the <code>COMPILE_FLAGS</code> properties of individual target source files instead. This will break the usage of the source file for multiple targets.</p>
<h2>multi-architecture builds under Mac OS X</h2>
<p>Neither GCC nor Clang support the use of precompiled headers when performing a Mac OS X multi-architecture build (e.g., using option <code>-DCMAKE_OSX_ARCHITECTURES=i386;x86_64</code>).</p>
<h2>Objective-C</h2>
<p>CMake targets that contain Objective-C or Objective-C++ source files cannot be cotired. Source files ending with .m and .mm are excluded by default through the initial default setting of <code>COTIRE_UNITY_SOURCE_EXCLUDE_EXTENSIONS</code>.</p>
<h2>Intel C++</h2>
<p>Intel C++ support has only been tested with <a href="https://software.intel.com/en-us/c-compilers/ipsxe-support">Intel C++ Composer XE 2013 for Linux</a> and may not work with other platforms or versions.</p>
<p>The Intel compiler may issue incorrect warnings #672 (the command line options do not match those used when precompiled header was created) or #673 (the initial sequence of preprocessing directives is not compatible with those of precompiled header file) upon compilation of cotired targets.</p>
<h2>IncrediBuild</h2>
<p>Cotire is not compatible with <a href="https://www.incredibuild.com/">Xoreax IncrediBuild</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jan 29 2022 17:29:44 for SimpleOneLibCPFTestProject by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
